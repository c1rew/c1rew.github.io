<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LeetCode]617. Merge Two Binary Trees]]></title>
    <url>%2F2019%2F06%2F01%2FLeetCode-617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[617. Merge Two Binary TreesGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: 1234567891011121314Input: trueTree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree:true 3true / \true 4 5true / \ \ true 5 4 7 Note: The merging process must start from the root nodes of both trees. 题目解释：合并两棵数，对应节点的值相加，其中一个为空的话，就留一个节点的数值； 方法一思路：左右两棵树分别递归合并，判断左子树和右子树合法性 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if (t1 == NULL &amp;&amp; t2 == NULL) &#123; return NULL; &#125; if (t1 == NULL &amp;&amp; t2 != NULL)&#123; return t2; &#125; if (t1 != NULL &amp;&amp; t2 == NULL)&#123; return t1; &#125; t1-&gt;val += t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return t1; &#125;&#125;; resultRuntime: 56 ms, faster than 12.37% of C++ online submissions for Merge Two Binary Trees. Memory Usage: 13.9 MB, less than 72.49% of C++ online submissions for Merge Two Binary Trees. 方法二上一个方法效率有点差，想了想，改了一下if语句的判断，效果提升明显。 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if (t1 == NULL &amp;&amp; t2 == NULL) &#123; return NULL; &#125; else if (t1 == NULL &amp;&amp; t2 != NULL)&#123; return t2; &#125; else if (t1 != NULL &amp;&amp; t2 == NULL)&#123; return t1; &#125; t1-&gt;val += t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return t1; &#125;&#125;; resultRuntime: 32 ms, faster than 99.18% of C++ online submissions for Merge Two Binary Trees. Memory Usage: 13.7 MB, less than 76.34% of C++ online submissions for Merge Two Binary Trees]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-10]]></title>
    <url>%2F2019%2F05%2F25%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-10%2F</url>
    <content type="text"><![CDATA[ARTS week-10Algorithm[LeetCode]461. Hamming Distance ReviewGoogle Maps Is Ready to Transform the World of Superapps: A Skift Deep Dive Google已经准备好成为superapp，特别在东南亚，提供了很多和地图相关的本地服务；但是Google并没有打算一举将这种服务扩大，一些服务本身是和Google的广告客户是冲突的，而且并没有解决用户的痛点；再一个是，目前提供的基于地图的服务，基本上是以“附近”为主，而没有把这个范围拓宽到其他服务。 PS：26mins左右的文章，我花了快一个小时才看完。。 TipMac和git在默认情况下大小写是不敏感的，导致重命名大小写及代码无法正常提交； git可以强制设为大小写敏感，并使用 git mv 进行文件重命名； Mac的大小写设置相对麻烦，不建议将系统设为默认大小写敏感，可能导致部分软件不可使用，但是可以通过新建一个大小写敏感的分区来进行文档的迁移； Share现实与理想-彭明辉]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现实与理想-彭明辉]]></title>
    <url>%2F2019%2F05%2F25%2F%E7%8E%B0%E5%AE%9E%E4%B8%8E%E7%90%86%E6%83%B3-%E5%BD%AD%E6%98%8E%E8%BE%89%2F</url>
    <content type="text"><![CDATA[假如这是一个充满善意的社会，人人愿意彼此急难救助，相互接纳、肯定，应该就很少有人愿意为了名利而付出夫妻失和、亲子生疏、心灵空洞等代价了；不幸的是，我们从来都没有经验过那样子有善意的社会。 本文转载自豆瓣 现实与理想/彭明辉，排版做了少量修改。 原文作者 维基百科-彭明辉](https://zh.wikipedia.org/wiki/彭明輝_(工程學家))，[清大彭明輝的部落格](http://mhperng.blogspot.com/)。 前言人生最困难的课题，莫过于现实与理想间的矛盾：我们希望有很高的收入和社会地位，让身边的每一个人羡慕、敬佩，甚至于连父母脸上都有光彩；但是，我们又不想要成 为金钱的奴隶，「赢得全世界却赔上自己」。 汽车后面的保险杆上流行一个贴条：「事业的成功，不能补偿家庭的失败。」但是，现在到处都可以看到失败的家庭：夫妻不合，亲子生疏；收入有余，却不知道如何安顿心灵。至于理想呢？到了四、五十岁的年纪，除了极少数的男人还有事业上的野心之外，绝大多数人对生命都失了的热情与憧憬，只知道什么叫做「生活上的享受」。人活了半百，一旦失去了对生命的热情与向往，活着的会不会只是一个没有灵魂的肉体和欲望？这样的人生有什么意义？很少人敢认真去面对这么一个质问！ 「金钱不是万能，没钱却万万不能。」这句流行话虽然很有理，大部分人却只是拿后半句话来强调现实的重要性。许多人不但不去深思「金钱不是万能」的涵义，甚至也没 办法深刻体会到「没钱万万不能」这句话在今天的实质意义。 在今日台湾的现实处境下，只要有固定的职业收入，绝大部分人都足衣足食：房子也许小一点、偏远一点；车子也许旧一点，但却衣食住行样样不缺。甚至在这个号称高失业率的年头，许多人还是靠着自己或长辈的储蓄在过日子，不肯屈就较辛苦、收入较少，或者社会地位较低的工作。既然大部分的人都已经有办法过足衣足食的日子，而远离了「没钱万万不能」的处境，为什么许多人都还是喜欢把这句话挂在嘴上呢？ 更奇怪的是：和光复初期比起来，现在台湾人的财富不知道增加了多少倍，但是现实的压力却更大了。我们看到许多人为了追求更高的收入与社会地位，而疏忽了夫妻关系的经营；为了「不要输在起跑点」，而把小孩子所有的时间交给各种补习班、双语学校、安亲班、才艺班。现在的年轻人，大部分只感到小时候的竞争压力，而感受不到情感的温馨和心灵内在的喜悦。现在四、五十岁的人，小时候虽然普遍地物质供应窘迫，却有着无忧无虑的欢乐童年。但是，现在二、三十岁的年轻人，却有太多人连童年都是活在惨白的竞争压力之下。 假如我们这个社会早已脱离了「没钱万万不能」的历史处境，今天的现实压力到底从何而来？ 一、人需要的不多，想要的很多人到底需要多少钱，才够满足现实上的需要？其实这根本没有绝对的标准，而是和身边的人比较出来的。小时候，家里不算宽裕。难得在餐桌上看到一锅炖肉，伸筷子去夹，在锅边就被祖母的筷子敲到一边去：「大人还没吃，小孩子等剩下的吃！」家里难得来个客人，没喝完的黑松汽水小孩子抢着喝。衣裤上只要没有补丁，就算是家境很不错，甚至足以傲人了。晚上睡觉，一家五口挤在三、四坪大的卧房里，床边还挤着一个臭气熏天的尿桶。今天四十岁左右的人，谁不是这样长大的？但是，当时谁曾经觉得自己苦？谁曾经觉得自己穷？现在每次看到电视广告里「我们都是这样长大的」的镜头，还不是会勾起许多人童年的甜蜜回忆？ 今日的台湾，只要肯工作，不得已时肯当大厦厕所的清洁工，谁的日子会过得比当年还穷？即使是九二一的灾区，只要平时有储蓄的习惯，都还可以过得远比我父亲那一辈人好：小学五年级就辍学，负责养活一家人，还包括一个卧病在床的父亲和一堆弟妹；到建筑工地挑砂石，挑不动；到空军基地的厨房当军夫，只为了可以把厨房用剩的油拿给家人吃；躲空袭，过了今天不知道有没有明天。这么苦的日子，只因为当时大家过的都一样，所以也不曾觉得苦。 想想我们童年时的物质条件，甚至我们上一代的物质条件，那样的生活都过来了，还有什么样的生活不能过？所以圣严法师说：「人需要的不多，但是想要的很多。」 托尔斯泰有一篇短篇小说，题名为：「人需要多少土地」。故事是这样开始的：在帝俄时代，有一个出身农奴的俄国人。他的体格很强健，又很努力工作，省吃简用，所以很年轻的时候就积存了足够的钱，给自己赎了身。从此以后，他租别人的田，继续努力耕作，不但更加省吃简用，甚至除了睡眠之外罕有休息，除非病得起不来否则天天下田。所以，到他壮年的时候，已经存够了积蓄，买到了几亩良田，成为一个小小的地主。他继续这样子吃苦耐劳地生活着，到了晚年的时候，他不但有十几顷的良田，甚至还有农奴在帮他耕作。不但衣食无缺，甚至丰盛有余。一般人在他这个年纪早已赋闲在家，颐养天年。但是，他仍积极地在寻找增加财富的各种管道。 有一天，他听说在南方靠近乌克兰的地方有一大片黑黝黝的肥沃土地，地上长的麦子远比他田里的还粗大又饱实。这片一望无际的沃土属于一个偏远的部落，他们对金钱的交易了解很少，只要给族长一小袋黄金，他就把你一天脚程内所能围绕起来的整片土地都送你。这个农夫盘算一下，一袋黄金只不过是他十分之一的储蓄，但一天脚程可以围绕起来的土地，却是他既有土地的十几倍。更何况，那里的土地都远比他现有的土地肥沃哪！所以他就赶快带着一小袋黄金和一个最强壮的仆人，赶到那个部落去。族长很热情地接待他，也证实了传闻中的土地交易方式，只多加了一句话：假如他日出时出发，而无法在日落时赶回到原点，他将一无所得，而那一袋黄金仍归族长所有。对他来讲，这个条件倒是很公允。所以他就把一袋黄金交给族长，并且挑了一块看起来最肥沃的土地，约定第二天天亮前在那里和族长碰面。 第二天一早他就起床吃了一顿丰盛的早餐，再叫仆人把昨晚准备好的木桩、午餐和饮水一起背在背上，趁天亮前赶到约定的出发地点，发现族长已经和族里一群喜欢热闹的 人一起在等他了。当第一道晨曦的光芒进入他眼帘的时候，他就急急忙忙地带着他强壮的仆人一起连走带跑地出发。 昨夜他就已经盘算好了：一出发他就往北走，等太阳升起到40度仰角的时候，他就要左转往西走，在接近中午的时候他要停下来边吃午餐边休息一个小时左右，然后左转往南走，当太阳落到40度仰角的时候，他再左转面向东方走回到原点。这样，他就可以在这片肥沃的土地上围绕出一块方方正正的土地。 他和仆人边走边打木桩。但是，当他朝北走到应该要左转往西走的时候，却发现前面的土地更肥沃。于是他想：「没有关系，我再往前走一段路，等一下再左转。反正我需要的是肥沃的土地，而不是方方正正的土地。」可是愈往前土地愈肥沃，害他一直朝着出发时往北的方向走下去，舍不得往左转，直到他意识到已经快接近中午了，才勉强狠心往左转。到了中午的时候，他才往西方走没多远的路，如果照计划左转往南走，他的土地将会非常狭长。因此，他改变了原来的计划，继续往西走。此外，他放弃了中午的休息，为了赶路而边走边吃。过了一段时间，他警觉到太阳已经快落到40度仰角的时候，他才焦急地想要左转往南走。可是算一算时间，如果这时候他才往南走，出发地点将在他的左方，他要到什么时候才能够再左转往出发点走呢？因为时间显然不够了，他只好放弃原来想拥有一块方正土地的期待，直接往出发点走过去，心里想着：「一块三角形的土地总好过一无所有！」 可是，他这个决定还是太晚了，眼见着太阳即将下山，他还看不到出发点。于是他焦急地奔跑起来，并催促着疲累的仆人把整袋木桩丢了来扶着他跑。他跑得又饥又渴却不敢停下来喝水，等他都已经喘不过气来的时候，才看到远远山顶上有一群人在出发点上等他。可惜的是，夕阳的最后一道余晖已经没入地平线下。他正伤心的时候，却发现出发点上的人又叫又跳，好像在鼓励他，为他打气。于是他想起来：出发点的地势比较高，所以还看得到夕阳。于是，尽管他已经喘不过气来了，还是拼命催促仆人搀扶着他往前没命地冲刺。终于，在夕阳的最后一道余晖中，他到达了出发点的山头，累得趴在地上──却从此再也起不来了！ 族长指挥着他的族人和这个农夫的仆人，就在山头上帮他挖了一个坟：六尺长、三尺宽、三尺深！ 这个老农夫死后到底有没有得到那块肥沃的土地呢？故事没有交代，其实读者也不会想知道。毕竟，人死后的财富是不值得关心的。 这个故事最令人震惊的是：这个农夫所付出的代价实在是太高了！只要他不那么贪得，他有很多机会可以不需要付出这个代价的。偏偏，人在追求财富的过程，往往像是中了蛊或着了魔一样：明知道贪欲已经过了头，有可能会为此付出痛心的代价，却总是欺哄自己说：「再多一点点就好了，我以后还有补救的机会。」就这样一直耽溺下去，直到一切补救的机会都已经消失为止。 可是，你读完这个故事以后就会完全解除对现实的恐惧与贪恋吗？不见得！假如人对现实的需要并不多，为什么人想要的又偏偏多出那么多？甚至于多到简直无止境，连生 命都可以赔上！ 二、现实的压力来自于精神上的惶恐，更甚于物质上的匮乏今天的台湾，虽不必然每个人都可以锦衣玉食，倒也真的是绝大多数人都可以足衣足食了。在这样的社会条件下，一个人只要学会储蓄与俭约的生活，不得已时愿意做别人不肯做的工作（当清洁工、值夜班、卖小吃），就可以免除现实的烦忧了。但是，很少有人愿意忍受这种简朴的生活。主要的原因是：谁都想出人头地，哪有人甘居人后，当工友让人指使？因此，与其说现实是一种不可或缺的物质需要，还不如说它是地位和成就的象征，是一种自我肯定的工具！所以，说到头来，现实根本是一种「精神上」的要求，而不是一般人所误以为的「生理要求」或「物质需要」。假如一个人不需要跟别人比就可以很满足（譬如得道高僧），他所需要的现实会很少；假如一个人整天都要跟别人比，给他再多都不够。 换个方式说，在今日的台湾，「现实」的意思已经不再是足衣足食了，而是「免于对未来生活的忧虑」，以及「成就感、被肯定、不受他人的轻蔑与羞辱」。 假如可以不花任何代价就获得一笔巨款，它将可以被用来保障我们未来的生活品质：不用怕中年失业、生病时可以给自己和家人最好的医疗照护，还可以用最昂贵的教育来保障孩子未来的竞争能力和生活品质。当一个人的财富多到三代也用不完的时候，他就真的可以不用再为现实烦忧了。还有更重要的，财富可以用来肯定自己的能力、赢取别人的尊敬与羡慕、让别人不敢卑视你。 相较之下，假如一个人的收入只足够应付眼前的衣食与住行，也许他可以不羡慕有钱人的物质享受，但是他却要如何去面对未来生活中不确定的风险（如失业、老年医疗）？更何况，一个收入低的人，如何面对亲戚眼光中的轻蔑，乃至于言语中坦白的的嘲讽与羞辱？从小到大，我们被重复地教会了一个现实：没有了钱，在别人眼中就连最基本的人格尊严也都没有了！ 我曾经问学生一个问题：「假如我是神仙，可以帮你实现一个愿望，但是你只能从以下两个愿望中挑一个，你会挑哪一个？（1）给你像比尔盖兹一样的财富，但是你要跟他一样，终日和钩心斗角、唯利是图的人生活在一起。（2）让你一辈子衣食无缺，没有多余的财富，也没有现实的压力，但是你一生中所接触到的人，都能肯定你，并且怀着善意接纳你。」听完这个问题，所有的人都用理所当然的口气说：「当然是后面那一个！」 这个简短的对话突显出几个事实：（1）大部分的人都想拥有比尔盖兹的财富，却不想要和钩心斗角、唯利是图的人生活在一起。也就是说，财富虽然吸引人，但是衡量过所需要付出的代价后，并不是每个人都愿意不惜一切代价去追求多余的财富。（2）对大部分的人而言，假如可以被肯定、被接纳、被善意地对待，那么他们对现实的所求就可以降低到「一辈子衣食无缺」的程度，而不愿意为了多余的财富付出没必要的代价。 其实，一个人只要职业稳定，有固定的收入与退休金（譬如公教人员），那么他将和比尔盖兹一样地一辈子不愁吃穿。因此，他们财富上的悬殊只能造成一个实质上的差异：他们死的时候，比尔盖兹会留下比较多钱。但是，死后的财富有什么意义呢？值得人为它做任何的牺牲吗？所以说，显然一般人所以羡慕比尔盖兹，为的不是他死后留下多少财产，而是这些财产在他生前带给他的自我肯定和别人羡慕的眼光。因此，人之所以会去追逐一生花不完的财富，积极的说是为了自我肯定，消极的说是为了自我武装，防范别人的轻蔑与羞辱。也正因为财富对人而言最大的吸引力是被肯定、被接纳，所以一旦我们可以不需付出任何代价就被肯定、被接纳的时候，我们就会吝于为多余的财富付出没必要的牺牲。因此，在前面的问答里，我们会选择「一辈子衣食无缺，没有多余的财富，但是被肯定、被接纳」；而不愿意为了比尔盖兹的财富，去忍受和唯利是图的人朝夕相处。 所以，假如这是一个充满善意的社会，人人愿意彼此急难救助，相互接纳、肯定，应该就很少有人愿意为了名利而付出夫妻失和、亲子生疏、心灵空洞等代价了。在这样的社会里，人们将会花费更多的心力，认真地去思索人生的意义，追求超出现实层次的「自我实现」。而平常被当作空话、不务实的理想、热情、憧憬、向往、心灵、生命等等东西，将会变得非常地吸引人，令人振奋，甚至于是「人要有滋味地活下去所不可或缺」的要素。 不幸的是，我们从来都没有经验过那样子有善意的社会。在这个现实的社会里，人都太势利。或者说，虽然人都或多或少隐藏着一些对人的善意，但是这个社会的习气却太恶质，使得这些善意根本无从传达、交流。从一懂事开始，我们就经常被亲戚和邻居拿来做为「比输赢」的工具。还没上幼儿园的时候就比看谁家小孩长得漂亮，看起来聪明。到了幼儿园，小朋友也学着大人的口气，比出国的次数，比汽车和房子的大小。小学开始就被拿来比成绩，比才艺，比英语，爸爸、妈妈、姑姑、阿姨、叔叔、伯伯都七嘴八舌地进来搅和，不把这场输赢的比较弄到沸腾就不罢休。难得过年，所有表兄弟姊妹玩在一起，偏偏就会有三姑六婆或阿姨、舅妈会问：「你们家慧娟功课好不好呀？」或者假猩猩地炫耀：「我们家志洁当了学校的小市长，回家都不肯讲，还是老师打电话来道贺才知道呢！」活在这种整天比输赢、争高下的恶质习气里，每个人自卫都来不及，根本没有机会表达出隐藏在心里的善意，甚至因为害怕天真的善意会换来无情的羞辱，以致于在一再的压抑之后，对自己的善意变得愈来愈迟钝而不敏感，最后甚至于感受不到它的存在！ 就这样子，我们每个人都被教养成随时在为不可预期的「决斗」作准备。收入再多都不够，随时可能会碰到一个亲戚或同学半路杀出来，用更高的收入把你踩到脚底下去。社会地位再高也不足，随时爸妈都可能会碰到一个失散多年的同学，用更杰出的儿子把你比下去，让你爸妈多年来的骄傲瞬间变成一团粪土。子女的成绩再好也不够，你随时可能会发现工友的儿子成绩更杰出，让你的自尊心变成别人脚底下的一块脏抹布。每次碰到熟人或陌生人，你都要机警地防范对方会不会无预警地出招，一刀毙命地残杀了你的自尊，让你的屈辱汨汨不绝从伤口涌出来，甚至让你在满溢的屈辱中窒息而死。 所以，我们急着用百万名车武装自己，从遥远的距离就开始发出自卫的讯号：「你们谁都别想瞧不起我！」我们用千万豪宅当武器，看谁不顺眼就轻描淡写地把对方的自尊心踩在地板上。在区公所被办事员刁难或瞪白眼的时候，就拿出亮丽的学位或头衔，逼对方弯下腰来道歉，甚至露出谄媚的神情来抱大腿。我们加入了那个「人欺人」的社会，用学位、豪宅、汽车、收入、储蓄、配偶的成就或容貌、子女的成绩和成就，以及一切可能的工具，一边武装自己，一边在必要的时候反击。开始的时候或许不习惯、不情愿，久了以后却像决斗岩流岛的宫本武藏，决斗成为一种本能，刀一出鞘就可以让对手尊严扫地、屈辱横流。然后，我们就可以偶而轻轻松松地感慨着说：「唉！这真是个人欺人的社会！」 然后，我们开始羡慕，甚至于崇拜，传说中的史丹福大学教授。他不但有亮丽的学位和头衔，而且自己在硅谷开一家上市的高科技公司，财产有好几十亿美元。从来都是别人听他的，没有人能够指挥他。所有他看上的女人，甚至不需要他开口，只要眨个眼，就会自动跟他上床。有一次机场因为大雪而下令所有飞机停飞，他硬是叫州长身边的要人打电话给机场主管，逼得机场塔台不得不让他起飞。这个人，就像美国人最崇拜的英雄：「他只负责定规矩，从来不需要遵从（He makes rules but follows none）。」这样的人，简直就是美国人心目中的宫本武藏。而在这个万事以美国为尊的台湾社会里，这样的人简直就是传奇英雄，每个人心目中的偶像。 于是，许多年轻人提起他们的「理想」时，他们说的就是这种「永远把别人踩在脚底下」的人。他们所谓的爱情，指的是每个异性都爱她╱他，但是她╱他却很可能不爱任何人。他们所谓的「自我肯定」，其实一半是自卫的姿态，一半是把别人踩在脚底下的欲望。他们所谓的「理想」，其实在中文字典里原本应该是叫做「野心」。 这是一个没有能力分辨什么叫鄙野、粗暴，什么叫崇高、热情的时代！ 当然，人是有护卫他的尊严的需要。但是，我们需要多少的财富、头衔与地位，才能达到自卫的需要？而这些财富、头衔与地位，又值得我们为它付出多大的代价呢？ 三、金钱只能换来虚假的情意，而换不来真心的接纳与善意托尔斯泰晚年写了一部很薄、也很感人的小说：【伊凡·伊列区之死】，探讨一个问题：「人一生中真正值得去追求的究竟是些什么？」 伊凡·伊列区是个高等法院检察长，有一个人人羡慕的漂亮太太，交往的都是彼得堡的上流阶级和贵族。他从小聪明伶俐，善于察言观色，也善于应对逢迎。因为出身贫苦，所以从小就力争上游，立志要出人头地。他聪明又用功，很顺利地拿到人人称羡的大学文凭。进入法院以后，他比别人更用心办案，也擅长交际，所以就比同事更快地获得各种升迁的机会。在人生最高峰的中年时，他和美丽的太太搬进了彼得堡宽敞的豪宅里，开始用心布置这个家。就在挂窗帘的时候，他从高高的梯子上摔下来，从此卧病不起。 从小到大，他第一次有很多时间去看他身周的人，以及他这一生真正所拥有的。虽然他很用心布置这个房子，极力想要摆脱中产阶级的品味，但是从家具到窗帘，没有一样东西和他相同社会阶级的人有任何的不同。就像他的一生，虽然他一直都不甘心当平凡人，但是却也从来不曾追求过任何和别人不一样的东西。因为，他从来都不曾知道自己在追求的是什么，也从来也不曾认真问过自己到底要的是什么！整个一生，他只是活在别人的期许和羡慕之中。所有他曾追求过的东西，都只是因为别人认为那些东西很体面，值得称许或羡慕，而没有一样是他自己要的。就像他的婚姻，不是因为两人相爱，而是因为大家都认为他们两人条件相当，未来将是非常体面的一对。 卧病以后，他那爱慕虚荣的的太太和女儿从来不曾真正关心过他。其实，他也从来不曾关心过别人。医生不在乎他的疼痛与忧虑，不把他当作一个有感觉有思想的人，只是机械化地用专业角度在处理他的身体。这就像他在法院一贯的风格，他只想从专业角度把所有的案件冷漠而优雅地处理掉，冷漠到近乎无情与残酷。即使发现当事人有冤屈或不得已的苦衷，他还是硬着铁石心肠依法办事。他的同事没有人同情他，反而整天在打听他的遗缺可以带给哪些人升迁的机会，就如同他以往在类似场合下会有的一贯作风。把他和家人联结在一起的力量不是爱情与亲情，而是虚荣心和一家人的面子；把他和同事连结在一起的，不是同事的情谊或关怀，而是社交的利益和人脉网络的经营。没有人是真心地活着，大家都只是活在别人的期许和羡慕里！ 当他看透了这一切，突然发现他从来不曾有过真心的喜悦和眼泪，不曾为自己的心愿而生活、奋斗，他的一生根本都是虚假的、空洞的、不值得的。他很想从头来过，尝试 过一种更贴心、更真实的人生。但是，他已经是绝症的末期，没有第二次的机会了！ 人生最可怕的，莫过于在人生已经不可能再重头开始的时刻里，却对自己有过的一生感到后悔、不值得！那么，人要怎么活这一生，才会觉得值得呢？我们曾否认真地想过 ？ 我问学生，你愿意花多少时间去准备你的婚礼？很多人都愿意花整整一个月的时间去筹备。那么，你是否曾经花一整天的时间去想想：「什么是你这一生中最想拥有、最珍贵的东西？」不曾有过！太忙了，国中开始忙联考，联考后还有联考，大学毕业后还有研究所，研究所毕业后要进园区。进了园区更忙，忙得有家归不得，有些人连想生小孩都找不到时间。 「那么，你会不会是第二个伊凡·伊列区，临死的时候才对一生后悔？」「不会吧！想办法赚钱解决现实的问题比较实际，没有必要花时间去想『人生观』这种无意义的问题！」 真的吗？大部分的人从一懂事开始就活在怕被别人比下去的恐惧当中，所以终其一生，他们只有在现实的恐吓下拼命地力争上游，追求财富与权势，作为武装自己和践踏别人的工具 ，却从来没有机会停下脚步来好好地想一想：这样子做，真的会解决他们的问题吗？ 可是，假如你会怕鬼，你总觉得鬼在你的身后。你愈是跑得快，愈是觉得背后有什么东西在追你。真的要解决这个恐惧，唯一的办法是停下脚步来，勇敢地往后面看清楚。只有当你敢往后面去看鬼的真相时，鬼才会消失掉。一味地在它的恐吓下拼命地往前跑，累死了也解决不了问题。面对现实的压力，道理也是一样的。只有当我们看透了现实能给我们，以及不能给我们的是什么之后，我们才有可能坦然地面对现实。 假如我们所以追求现实，为的是自我的肯定和别人的善意、接纳，这一定要用名利权位才能达成吗？还是说我们可以有更简洁、更有效的方式来肯定自我，并且获得别人更 真心的善意与接纳？ 让我们再来做一个实验：请你就认识的熟人中，选出五个你认为最值得尊敬的人，和五个你最讨厌的人，把他们的名字写在纸上。然后你仔细分析看看，你认为最值得尊敬的人当中，有几个刚好是学历最高、或者最富有、或者最有权势的？除此之外，你也仔细查查看，最让你受不了的人中，有几个刚好是学历最高、或者最富有、或者最有权势的？很多人都会发现：在名、利、权、位的追逐上愈成功的人，往往也是最讨人嫌的人！那么，这个社会为什么普遍鼓励我们去追逐名利与权位？因为这些东西对陌生人很有效！ 譬如，你到户政事务所去办文件，承办人对前面几位都大小声，乱发脾气。轮到你的时候，他看到你光鲜亮丽的衣着和你先生的博士头衔，态度突然柔和谦卑起来，这时候会让你觉得衣饰和头衔很好用。但是，这些表面上的荣耀与光彩，只对陌生人有用。对于那些和我们朝夕相处的人而言，名利与权位很难影响到他们对我们的善意与肯定。譬如说，你最要好的朋友或许会在你获得博士学位时为你高兴一下下，但是没多久你和他的关系又回复到以往的状态。反过来说，假如有人因为你新获得的名利与权位而急着和你结交，这种虚情假意的朋友还不如不要！ 绝大部分的人都和伊凡·伊列区一样，花费一生的精力去追求表面上的荣耀，虽然这会换来许多陌生人的羡慕与激赏，却换不来身边人真心的善意与对待。一辈子只为了一群不相干的路人而活着，值得吗？很多全球著名的艺人都有酗酒、吸毒的麻烦，就因为舞台上的风光掩饰不住私生活中的空洞与虚幻。 我没有办法许诺你一生当中所遭遇到的人都接纳你、肯定你、对你怀着善意。但是，如果要做到「你常接触到的人大多数都接纳你、肯定你、对你怀着善意」，这并不会很 难，而且它和你所拥有的权势、名利、地位几乎毫不相干。其实你要做的，只不过是对别人时时怀着善意。金钱换不来人的善意，只有善意可以换来善意。假如你希望熟人对你有善意，最重要的是你要有能力对别人怀着善意。终身在印度救济贫民的泰瑞莎修女，她在全球所获得 的肯定、尊敬与善意，远远超过比尔盖兹和英国女皇。 假如你是一个对生命的真谛有深刻体认的人，而且对别人怀着善意，那么所有认识你的人都会尊敬你、接纳你，并且对你怀着善意。当然，大部分的陌生人还是看不到你对生命的体认，因而只能从外表的判断对你漠视、轻蔑，甚至羞辱你。但是，假如你真的对生命的真谛有深刻体认了，你还会在意别人只凭外表所做出的轻率判断吗？ 所以，我们所以需要外在的现实武装来保护自己，真正的原因是：我们想用它来遮掩我们内在的贫乏（包括智性的与情感的）。但是，一个内在贫乏的人，不管他在外表尚有多么足以夸耀的权势、名利与地位，他自己会知道自己的贫乏，他的亲人会知道，而他身周的朋友也都会知道。我们可以愚弄马路上的陌生人，却愚弄不了自己，以及身周朝夕相处的人。因此，想要靠权势、名利与地位去换得身周熟人的肯定与尊敬，还不如努力去累积自己的人生智慧和对人的善意。 伊凡·伊列区一生最大的错误，就是没有警觉到：挣取权势、名利与地位的过程需要耗费大量的时间和心力，而累积人生智慧和善意的过程也需要耗费大量的时间和心力，因此，赢得权势、名利与地位的过程必然牺牲了我们可以用来累积人生智慧和善意的资源。结果，一个人在权势、名利与地位的追逐上愈成功，往往他在人生智慧和善意的累积上愈贫乏。一个外表亮丽而内在贫乏的人，注定只能吸引陌生人的羡慕，而无法赢得身周人的真心肯定与善意。 所谓「赢得全世界而失去了自己」，正是伊凡·伊列区的写照。但是，它却也正是整个社会盲目地在追求的人生目标。当你仔细看清楚这个真相的时候，会不会一身冷汗？ 四、没有了憧憬与热情，生命还有什么味道？人活着，假如生命里早已不再有任何的感动、向往与憧憬，而只剩下虚荣和财富，以及为了把别人踩在脚底下而终日无歇地苦劳与钩心斗角，这样的人生，究竟是什么样的 滋味？这样的人，和行尸走肉有什么差别？ 但是，大部分的人都只是盲目地想延长寿命，而很少去注意活着的品质。所以，即使看透了「现实的成就换不来别人真心的接纳与善意」，很多人还是舍不掉对财富的盲目 追逐。因为，财富可以用来保障未来的生活与医疗品质，还可以用来延长寿命。 居安思危的风险管理其实是值得提倡的，但却没有必要让它变成一种毫无节制的夸张性恐慌。假如只是要保障家人在自己意外之后可以有最起码的生活能力，消费性保险的保费是一个有限的财力负担，并不需要为了它而终日追逐无穷无尽的财富。但是，大部分人真正担心的却是：假如罹患绝症，而没有足够的财富接受长期耗费巨资的医疗，怎么办？ 大陆有个叫马桥的偏远小镇，在那里年轻人叫做「贵生」，上了五十岁的人叫做「贱生」。年轻时活得健康、有憧憬、有热情、有活力，生命是可贵的，所以叫「贵生」；上了五十岁，齿危发秃，吃不得、动不得、浑身是病，死拖活赖地活着其实也不是什么特别值得高兴的事，所以叫「贱生」。所以，活不活得好不好，其实远比活多久还重要。 一位六十多岁的医师发现自己有癌症，考虑良久之后，决定不就医，而把一部份财产捐给慈善机构后就去旅行了。医界朋友说他不肯和癌症抵抗是为病人立下一个错误的范例，他回答：假如我决心和癌症对抗，可能要花好几年的时间卧在病床上，即使治好也是身体虚弱，不能再好好利用我的残年。但是假如我不浪费时间在病床上，就可以利用这三五年，好好去做我一直期待着要做的事。何况，与其拿庞大的财富去医治一个原本就已自然地衰老的身体，还远不如把这钱给非洲那些贫困而健康的儿童，让他们有机会好好地度过一生！ 大部分人都只是未经深思地企图延长肉体的生命，却从来不曾思索过：要怎么活才是值得？从释迦牟尼的角度看，除非人活着是为了一些憧憬与向往，否则无趣地活着而时 时必须忍受生老病死的各种苦，实在没什么道理。 人所以能热切而充满活力地生活着，是因为他对人生还怀有着期待与盼望，因为他还有理想与热情；而生活之所以困乏而无趣，则是因为我们已经丧失掉对人生的好奇以及对未来的憧憬。假如一个人早已丧失掉生命里所有的感动、热情、向往与憧憬，就算给他全部的现实，他还有可能靠着空洞的躯壳去活出有滋味的人生吗？偏偏，很多人都发现：现在赚的钱远比小时候所能想象的多了几十倍，却比小时候所能想象的还更不快乐！ 回想起小时候，每天一张开眼就急切地翻身下床，兴奋地往外面跑，对这个世界充满着好奇与盼望，对人生充满着向往与期待。但是，长大后有钱了，自己可以作主了，却反而失去了对人生的憧憬与期待。人生，好像就意味着无尽的苦劳，以及永远不会终止的输赢和野心！即使偶而和朋友嬉闹、聚餐、逛街、乃至于party，那种欢乐不管多兴奋、刺激，都好像气球里的空气，过一夜就消散得无影无踪。每次狂欢之后，最难忍受的是随之而来的怅惘与失落感。长大以后的快乐好像都很不实在，很少能留在记忆里。 面对这种现象，很多人都会不假思索地说：「长大了就要面对现实呀，只有长不大的人才会甩不掉小时候的天真！」言下之意，现实虽然是一种无奈，却是人活着所不得不认真面对的。假如活着真的就是一种无奈，死活又有什么好挂虑的？人又何必为了不可测的未来而整天辛辛苦苦地钻营财富？显然，活多久根本不是重要的问题，重要的是活得起不起劲！ 很少人能体认到：其实，人活着，最重要的不是现实上的成就，而是保持心中的憧憬、向往与喜悦。假如我们能像小孩子一样随时保持着对这世界的好奇、憧憬与向往，我们的心就会随时保持着喜悦。在那种心情下，现实的一切都很难对我们造成困扰。反之，当我们对人生的热情、理想、憧憬与向往愈淡薄的时候，现实对我们的纠葛就愈深。所以，与其说人是因为现实的存在而丧失了理想，不如说人是因为丧失了理想所以才会掉入现实的漩涡。 那么，人的热情与理想怎么会消失呢？很多人都不知道理想与热情是需要细心栽培、灌溉、维护、修补的。甚至于理想与热情是需要我们花费很大的心力去创造、经营的。小孩子所以能够随时保持着对这世界的好奇、憧憬与向往，确实是因为他们未经世事，因此对他们而言，天底下没有哪一件事情是不可能的。我问一个幼儿园的小朋友：「假如我给你一千块钱，你要拿它做什么？」他说：「给我妈妈买一座城堡。」对他们而言，明天就是一切的可能性。不管是什么事情，如果今天做不到，那么只要等他长大，他就会做得到。 但是，对大人而言，所有今天不可能的，明天将更加地不可能。随着年纪愈大，我们愈清楚地知道现实的局限性。尤其是四十岁的人，所有能得到的他都已经得到了，所有还未得到的他都已经尝试过了，现在不可能的都永远不再有可能了。于是，生命成为一摊死水，困窘而促狭地被挤压在一个小小的角落里，怎么样子都活不开来。 不过，也不是所有的成年人都这样。有些人机缘好，在童真的热情消失之前，他们就已经利用年少时的热情发展出新的憧憬与盼望，把它给寄托在文学、艺术或者对于大自然的关爱当中。随着年龄渐长，他们的情感持续获得更宽广多样的滋润，从戏剧、舞蹈、音乐、文学、电影、哲学与宗教作品中，他们一再经历心灵被激励、提升、陶醉的感动。在这个绵延数千年的历史人文精神里头，他们感受到生命内在的活力与无限开展的可能性；在前人的引导下，他们见证着人类精神世界的波澜壮阔与甘苦酸甜。对这样的人而言，活着就是一种可能！对他们而言，人的热情有生灭、有消长、有困顿与丰盈，却不会了无生机。因为，通过戏剧、舞蹈、音乐、文学、电影、哲学与宗教作品的传承，我们随时有机会去亲近过去四千年来人类最极致而精粹的生命经验，以及最璀璨动人的时刻。 当我们感受到自己的情感愈来愈细腻深刻，思想愈来愈开阔透彻时，我们也见证着自己内在生命的生机与开展。活在这样一种持续的开展之中，我们才能够有信心地说：活着，就是一种可能。也因此，我们才能够信心满满地对人生怀着憧憬与热情。活在这样的情境里，我们不需要别人羡慕的眼光就能够自我肯定，被陌生人鄙视时也能坦然地面对自己。这样的自我肯定，远比通过财富或名利更来得踏实。这样地活，才真正活得有滋味。只有体会过这种生命的滋味的人，才能真心信服圣经里的许诺：「不要为生命忧虑吃什么，为身体忧虑穿什么；因为生命胜于饮食，身体胜于衣裳。你想想乌鸦，它也不种也不收，又没有仓又没有库，上帝尚且养活它。你们比飞鸟是何等地贵重呢！你们哪一个能用思虑使寿数多加一刻呢？这是最小的事，你们尚且做不到。为什么还忧虑其余的事呢？你想百合花怎么长起来；它也不劳苦，也不纺线。然而我告诉你们，就是所罗门极荣华的时候，他所穿戴的，还不如这朵花呢！你们这些小信的人哪，野地里的草今天还在，明天就丢到炉里，上帝还给它这样的妆饰，何况你们呢！」── 路加福音12:22 结语现实，是人活着不可逃脱的必要条件。但是，真正的现实，不过是足衣足食而已。人会把现实夸大到那么令人惶恐的程度，其实是因为他已经丧失了对生命的热情、憧憬与向往，却又不甘愿让生命归于徒然而一无所有的虚空。但是，财富换不来真诚的善意与接纳，也阻挡不住生命中空虚的呐喊。其实，一旦能做到衣食无缺之后，人真正的需要是热情、理想、憧憬与向往，而不是现实。但是，离开童年之后，人的热情、理想、憧憬与向往是需要花心力去培养、经营与创造的。可悲的是，人经常花了太多的时间在经营他的现实，以致让他的热情、理想、憧 憬与向往一一消耗殆尽，只剩下空洞的灵魂，在陌生人的羡慕中，困窘地而孤单地反复着没有滋味的人生。 现实诱惑很多，理想总是会相对骨感一些，为了达到心之所向，就需要抛开他人的评价与闲言碎语，遵从内心的想法，不能被过去的事、过去的人所羁绊；着眼于当下，走好脚下的每一步，你对镜子笑，镜子也会对你笑；奋斗的岁月，时间会回馈给你相应的果实，各位，共勉。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>现实</tag>
        <tag>理想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]461. Hamming Distance]]></title>
    <url>%2F2019%2F05%2F21%2FLeetCode-461-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[461. Hamming DistanceThe Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. Example: 12345678910Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 题目解释：两个整数，计算转换成二进制后，同一个位置上，两个数不同的有几个。 思路：算出所有不同的位置，直接用异或，再去统计所有异或出来的‘1’的个数。 1234567891011class Solution &#123;public: int hammingDistance(int x, int y) &#123; int n = x^y; unsigned int c =0; for (c =0; n; n &gt;&gt;=1) &#123; c += n &amp; 1; &#125; return c; &#125;&#125;; resultRuntime: 0 ms, faster than 100.00% of C++ online submissions for Hamming Distance. Memory Usage: 8.2 MB, less than 73.49% of C++ online submissions for Hamming Distance. 逛了一遍讨论区，各种奇技淫巧，效果并没有更好，找不到内存占用小于8.2MB的办法，如果有谁找到了，麻烦留言告知。 123456class Solution &#123;public: int hammingDistance(int x, int y) &#123; return bitset&lt;32&gt;(x^y).count(); &#125;&#125;; 1234567891011class Solution &#123;public: int hammingDistance(int x, int y) &#123; int dist = 0, n = x ^ y; while (n) &#123; ++dist; n &amp;= n - 1; &#125; return dist; &#125;&#125;; 123456class Solution &#123;public: int hammingDistance(int x, int y) &#123; return __builtin_popcount(x^y); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-9]]></title>
    <url>%2F2019%2F05%2F19%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-9%2F</url>
    <content type="text"><![CDATA[ARTS week-9Algorithm[LeetCode]961. N-Repeated Element in Size 2N Array ReviewDon’t Use a VPN at Home 在有强wifi密码和https的情况下，使用vpn并不能带来更高的安全保护； 作者说的也是挺有道理的，不过我还是想用梯子上Google(黑脸表情)。 TipMac 截屏快捷键 Command+Shitf+4 Sharegit clone 加速]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clone 加速]]></title>
    <url>%2F2019%2F05%2F19%2Fgit-clone-%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[起因为了修改自己博客的文件夹命名，就需要将github上的仓库下载到本地，使用git clone时，速度慢到无法接受，就Google了一番git clone加速的办法，记录下来，以便后续查阅。 github速度慢是因为DNS被污染了，原因你懂的，对于解决github的问题，使用代理可能是最好的办法了 使用代理使用这个方法的前提，是你有一个梯子，这个梯子能够让你正常访问Google，梯子怎么搭，这里就不赘述了，我们这里假设你已经有梯子可用，可以设置git通过代理进行访问； 起初我使用了v2ray的全局模式，执行git clone后，发现速度并没有任何变化，Google后发现，git命令并不会直接走全局代理，需要通过git config配置，看完所有命令再操作； 12345678# 千万别急，刚开始而已# socks5协议，1080端口修改成自己的本地代理端口git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080# http协议，1081端口修改成自己的本地代理端口git config --global http.proxy http://127.0.0.1:1081git config --global https.proxy https://127.0.0.1:1081 以上的配置会导致所有git命令都走代理，但是如果你混合使用了国内的git仓库，甚至是局域网内部的git仓库，这就会把原来速度快的改成更慢的了； 下面是仅仅针对github进行配置，让github走本地代理，其他的保持不变； 1234567# socks5协议，1080端口修改成自己的本地代理端口git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080# http协议，1081端口修改成自己的本地代理端口git config --global http.https://github.com.proxy https://127.0.0.1:1081git config --global https.https://github.com.proxy https://127.0.0.1:1081 其他几个相关命令： 12345# 查看所有配置git config -l# reset 代理设置git config --global --unset http.proxygit config --global --unset https.proxy 看下使用了本地代理前后，速度的差距： Reference 给 github clone 加速 github代码clone加速 第2点的这个方法，没试过，不知道可不可行，感兴趣的朋友可以试试看。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]961. N-Repeated Element in Size 2N Array]]></title>
    <url>%2F2019%2F05%2F15%2FLeetCode-961-N-Repeated-Element-in-Size-2N-Array%2F</url>
    <content type="text"><![CDATA[961. N-Repeated Element in Size 2N ArrayEasy In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: 12Input: [1,2,3,3]Output: 3 Example 2: 12Input: [2,1,2,5,3,2]Output: 2 Example 3: 12Input: [5,1,5,2,5,3,5,4]Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 方法一12345678910111213141516171819class Solution &#123;public: int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123; int n = A.size()/2; map&lt;int, int&gt; item_map; int target; for (int item : A) &#123; if (item_map.count(item)) &#123; if (++item_map[item] == n) &#123; target = item; break; &#125; &#125; else &#123; item_map.insert(make_pair(item, 1)); &#125; &#125; return target; &#125;&#125;; resultRuntime: 88 ms, faster than 8.10% of C++ online submissions for N-Repeated Element in Size 2N Array. Memory Usage: 17.4 MB, less than 6.23% of C++ online submissions for N-Repeated Element in Size 2N Array. 方法二审题啊，审题，审题不详细，代码写再多也是枉然，题目中明确说明，只有一个数字是重复的，其他都是唯一的，这个时候用set最好解决了； 123456789101112131415class Solution &#123;public: int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123; set&lt;int&gt; item_set; int target; for (int item : A) &#123; if (item_set.count(item)) &#123; return item; &#125; else &#123; item_set.insert(item); &#125; &#125; return -1; &#125;&#125;; resultRuntime: 40 ms, faster than 88.98% of C++ online submissions for N-Repeated Element in Size 2N Array. Memory Usage: 10.8 MB, less than 68.86% of C++ online submissions for N-Repeated Element in Size 2N Array. 效果显著，但是不是特别好。 逛一下讨论区，看看网友们的奇技淫巧： https://leetcode.com/problems/n-repeated-element-in-size-2n-array/discuss/208563/JavaC%2B%2BPython-O(1)-Solution 这个作者的方法二和方法三，实在是令人惊叹。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-8]]></title>
    <url>%2F2019%2F05%2F12%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-8%2F</url>
    <content type="text"><![CDATA[ARTS week-8Algorithm[LeetCode]657. Robot Return to Origin ReviewGoogle Takes a Bite Out of Apple 苹果作为软硬件一体的公司，过去对于隐私的控制始终都处在业界领先；不过这一次的Google IO大会之后，这个优势可能会有所减弱； 控制隐私和安全成了此次Google IO大会的一大主题，也成为Google开发许多产品的基石，包括很多产品的隐身模式，还有人脸识别的本地化，最重要的一个产品，应该是人工智能的联合学习，不再需要一堆的数据上传到服务器进行集中训练，而是在终端就可以进行个人数据的个性化学习； 随着全球公众以及政府监管对于隐私安全的逐渐重视，Google对于隐私安全的重视更像是无奈之举，否则可能面临难以估量的后果。 TipJupyter notebook删除cell，Esc—&gt;dd。 Jupyter notebook快捷键 ShareJupyter notebook配置]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook配置]]></title>
    <url>%2F2019%2F05%2F12%2FJupyter-Notebook%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[起因每次更换电脑或者要新建一个Jupyter Notebook环境，都要查找好几个网站，去配置好开发环境，记录一下所有配置，以后就不用频繁使用搜索引擎，却只为了寻找几句配置。 简介Jupyter Notebook是个开源的Web应用，可以创建包含代码、公式、可视化及叙事文本的共享文档； 支持超过40种编程语言 可共享的notebook 交互式的输出 集成大数据工具 配置1. 生成配置文件1jupyter notebook --generate-config 2. 设置密码1jupyter notebook password 3. 修改配置文件12345vim ~/.jupyter/jupyter_notebook_config.py修改以下三个节点的配置，并把开头的 # 注释去掉c.NotebookApp.ip = '*' # 开启所有的IP访问，即可使用远程访问c.NotebookApp.open_browser = False # 关闭启动后的自动开启浏览器c.NotebookApp.port = 8888 # 设置端口8888，也可用其他的，比如1080，8080等等 4. 启动notebook1jupyter notebook 5. 远程访问在浏览器输入http://hostip:8888，hostip可以是本地地址，局域网地址，也可以是远程服务器地址(比如阿里云或者AWS或者其他云服务器厂商的VPS外网地址)。 6. 主题12345678pip install jupyterthemes# list available themes# onedork | grade3 | oceans16 | chesterish | monokai | solarizedl | solarizeddjt -l# select theme...jt -t chesterish 详细步骤还可以查看该工程的github主页：https://github.com/dunovank/jupyter-themes Reference https://jupyter.readthedocs.io/en/latest/projects/config.html https://github.com/dunovank/jupyter-themes]]></content>
      <categories>
        <category>Jupyter</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]657. Robot Return to Origin]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-657-Robot-Return-to-Origin%2F</url>
    <content type="text"><![CDATA[657. Robot Return to OriginThere is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is “facing” is irrelevant. “R” will always make the robot move to the right once, “L” will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. Example 1: 123Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: 123Input: &quot;LL&quot;Output: falseExplanation: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves. 大概解释一下题目：机器人从原来（0,0）开始走，用键盘上下左右键，判断最后机器人是否回到原点。 方案一思路：判断是否回到原点，就是左右走动的格数要相等，上下走动的格数也要相等，即count(L) == count(R)而且count(U) == count(D)，循环遍历，代码如下： 1234567891011121314151617class Solution &#123;public: bool judgeCircle(string moves) &#123; map&lt;char, int&gt; move_map; for(char item : moves) &#123; if(move_map.count(item)&gt;0) &#123; move_map[item] = move_map[item]+1; &#125; else &#123; move_map.insert(make_pair(item, 1)); &#125; &#125; if ((move_map['U'] == move_map['D']) &amp;&amp; (move_map['R'] == move_map['L'])) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 36 ms, faster than 7.05% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.3 MB, less than 98.06% of C++ online submissions for Robot Return to Origin. 方案二用两个堆来匹配，U遇到堆顶是D，则pop，否则push，其他类似： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool judgeCircle(string moves) &#123; stack&lt;char&gt; updown_stack; stack&lt;char&gt; lr_stack; for(char item : moves) &#123; if(item=='U') &#123; if (!updown_stack.empty() &amp;&amp; updown_stack.top()=='D') &#123; updown_stack.pop(); &#125; else &#123; updown_stack.push(item); &#125; &#125; else if(item=='D') &#123; if (!updown_stack.empty() &amp;&amp; updown_stack.top()=='U') &#123; updown_stack.pop(); &#125; else &#123; updown_stack.push(item); &#125; &#125; else if(item=='R') &#123; if (!lr_stack.empty() &amp;&amp; lr_stack.top()=='L') &#123; lr_stack.pop(); &#125; else &#123; lr_stack.push(item); &#125; &#125; else if(item=='L') &#123; if (!lr_stack.empty() &amp;&amp; lr_stack.top()=='R') &#123; lr_stack.pop(); &#125; else &#123; lr_stack.push(item); &#125; &#125; &#125; if (updown_stack.empty() &amp;&amp; lr_stack.empty()) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 20 ms, faster than 64.52% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.6 MB, less than 28.68% of C++ online submissions for Robot Return to Origin. 方案三被固定思维所限，其实只要计算左右和上下的次数，用int值来判断就可以，下面这个方案就很好： 12345678910111213141516171819202122class Solution &#123;public: bool judgeCircle(string moves) &#123; int updown=0; int lr=0; for(char item : moves) &#123; if(item=='U') &#123; updown++; &#125; else if(item=='D') &#123; updown--; &#125; else if(item=='L') &#123; lr++; &#125; else if(item=='R') &#123; lr--; &#125; &#125; if (updown==0 &amp;&amp; lr==0) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 16 ms, faster than 96.59% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.3 MB, less than 97.29% of C++ online submissions for Robot Return to Origin.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-7]]></title>
    <url>%2F2019%2F05%2F05%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-7%2F</url>
    <content type="text"><![CDATA[ARTS week-7Algorithm[LeetCode]832. Flipping an Image ReviewDrones Transporting Organs For Transplant Is Now A Reality 使用无人机运输需要移植的器官已成为现实 未来将拯救更多生命，无人机作为运输工具，而不再仅仅是娱乐或者是亚马逊的“快递员”哈 从成本上看，肯定是比直升机要低很多，但是作为正式使用的工具，肯定还有很长的路要走，毕竟整个运输过程，器官的安全完整送达，是重中之重；不过已有的成功案例，也让我们对这个方向有所期盼，为这个社会带来更多积极影响。 Tipwindows 10 ubuntu 子系统 中文乱码问题，执行以下命令后，重新开启终端即可； 1234apt-get updateapt-get install language-pack-zh-hansupdate-locale LANG=zh_CN.UTF-8 # 可以选择下面这句update-locale LANG=en_US.UTF-8 # 其实为了支持中文的显示，只需要支持utf8的显示即可 Share本周分享一篇2016年底的老文章，但是现在看来，依然具有参考意义。 谷歌求职记：我花了八个月准备谷歌面试 英文原文：Why I studied full-time for 8 months for a Google interview 作者针对Google面试所列的github仓库：coding-interview-university，里面也有对应的中文版。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]832. Flipping an Image]]></title>
    <url>%2F2019%2F05%2F02%2FLeetCode-832-Flipping-an-Image%2F</url>
    <content type="text"><![CDATA[832. Flipping an ImageGiven a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: 1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: 1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 题目大概解释一下：二维数组，水平翻转，再取反。 方案一思路：遍历每一行，对每行的元素先做翻转，再取反，时间复杂度 n^2 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; reversAndInvert(vector&lt;int&gt; &amp;in) &#123; int len = in.size(); vector&lt;int&gt; out(len); for(int i = 0; i &lt; len; ++i) &#123; out[i] = !in.at(len-1-i); &#125; return out; &#125; vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int len = A.size(); vector&lt;vector&lt;int&gt;&gt; result(len); for(int i = 0; i &lt; len; ++i) &#123; result[i] = reversAndInvert(A.at(i)); &#125; return result; &#125;&#125;; resultRuntime: 20 ms, faster than 21.52% of C++ online submissions for Flipping an Image. Memory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Flipping an Image. 预料到时间会比较高，毕竟时间复杂度是 n^2（后面解释，慢竟然不是因为这个原因）。 方案二从讨论区里面找到一个方案，再稍微修改下，使用了reverse函数，并通过引用修改原有元素，而且使用了异或操作。 123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; for (auto &amp; row : A) &#123; reverse(row.begin(), row.end()); for (int &amp; i: row) &#123; i ^= 1; &#125; &#125; return A; &#125;&#125;; resultRuntime: 12 ms, faster than 100.00% of C++ online submissions for Flipping an Image. Memory Usage: 9.3 MB, less than 99.61% of C++ online submissions for Flipping an Image. 其实套路基本差不多，但是有个很关键的操作 i ^= 1;，这个异或操作比方案一的 ! 操作，效率高很多。 把方案一的 ! 操作，换成异或后，也得到了类似的效果，不过新开辟的vector就多了空间复杂度。 Runtime: 12 ms, faster than 100.00% of C++ online submissions for Flipping an Image. Memory Usage: 9.5 MB, less than 99.22% of C++ online submissions for Flipping an Image.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-6]]></title>
    <url>%2F2019%2F04%2F28%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-6%2F</url>
    <content type="text"><![CDATA[ARTS week-6Algorithm[LeetCode]977. Squares of a Sorted Array ReviewAs a Leader, Time Is Your Most Valuable Resource 作为领导者，时间是你最有价值的资源。 要确保你做的所有事都是在帮助你完成最重要的那个目标。 就像凯勒･帕帕森的书《最重要的事，只有一件》。 还有一个规则，就是断舍离，留下那个丢弃后造成痛苦最大的东西。 Tiptuple，可以存放不同类型元素的容器，这周在一个功能开发中使用到了； 手册地址：tuple SharePyTorch 逻辑回归]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 逻辑回归]]></title>
    <url>%2F2019%2F04%2F28%2FPyTorch-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[逻辑回归回归模型，作为机器学习的基本模型，上一次练习了线性回归，这次就说说Logistic Regression。 PyTorch代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import torchimport numpy as npimport torch.nn.functional as Ffrom torchvision import datasets, transformsimport matplotlib.pyplot as pltin_dim = 28*28out_class = 10batch_size = 64# 迭代次数 100epochs_num = 100class LogisticRegression(torch.nn.Module): def __init__(self): super(LogisticRegression, self).__init__() self.logistic = torch.nn.Linear(in_dim, out_class) def forward(self, x): return self.logistic(x) model = LogisticRegression()# 交叉熵损失loss_function = torch.nn.CrossEntropyLoss()# 随机梯度下降，学习率 1e-3#optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)# 另外一个优化方法 Adamoptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)def train(model, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data = data.view(data.size(0), -1) output = model(data) loss = loss_function(output, target) optimizer.zero_grad() loss.backward() optimizer.step() if batch_idx % 100 == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item()))def test(model, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data = data.view(data.size(0), -1) output = model(data) test_loss += loss_function(output, target).item() # sum up batch loss pred = output.argmax(dim=1, keepdim=True) # get the index of the max log-probability correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset)))train_loader = torch.utils.data.DataLoader( datasets.MNIST('./data', train=True, download=True, transform=transforms.ToTensor()), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST('./data', train=False, transform=transforms.ToTensor()), batch_size=batch_size, shuffle=True)for epoch in range(epochs_num): train(model, train_loader, optimizer, epoch) test(model, test_loader) 可以调整学习率、迭代次数、优化方法，看看不同的调整，会有什么不同的结果 使用SDG，学习率为1e-3时，收敛速度有些慢，迭代了73次才达到91\%，最终准确率稳定在$91\%$； 使用Adam，学习率一样为1e-3，收敛速度很快，一轮就能达到90\%，接下来就是一直在90\% 和 91\%之间徘徊； 简单的回归，对于多分类还是心有余而力不足，后面会再用二分类练习逻辑回归，也会用神经网络来训练下MNIST数据集。 SDG训练了100次后的结果，如下图： 代码也可以查看我的GitHub仓库LogisticRegression，如有错误，欢迎指出。]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]977. Squares of a Sorted Array]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-977-Squares-of-a-Sorted-Array%2F</url>
    <content type="text"><![CDATA[977. Squares of a Sorted ArrayGiven an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Example 1: 12Input: [-4,-1,0,3,10]Output: [0,1,9,16,100] Example 2: 12Input: [-7,-3,2,3,11]Output: [4,9,9,49,121] Note: 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A is sorted in non-decreasing order. 大概解释下题目：有序的有符号数组元素平方后排序。 方案一思路：迭代循环每个元素进行平方，然后再用sort排序 1234567891011class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; unsigned int size = A.size(); for (unsigned int i = 0; i &lt; size; ++i) &#123; A[i] = A[i]*A[i]; &#125; sort(A.begin(), A.end()); return A; &#125;&#125;; resultRuntime: 124 ms, faster than 45.70% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.4 MB, less than 100.00% of C++ online submissions for Squares of a Sorted Array. 内存占用效果不错，但是执行效率就差了，for循环的原因？ 方案二新建一个数组替换原来的A 123456789101112class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; unsigned int len = A.size(); vector&lt;int&gt; out(len); for (unsigned int i = 0; i &lt; len; ++i) &#123; out[i] = A[i]*A[i]; &#125; sort(out.begin(), out.end()); return move(out); &#125;&#125;; resultRuntime: 120 ms, faster than 58.11% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.5 MB, less than 99.64% of C++ online submissions for Squares of a Sorted Array. 效果并没有好多少。 方案三读题不够仔细，原始数组就是有序的，只不过是包含了负数而已，这个排序就可以用来比较了，以下这个方案是讨论区的答案，有点巧妙。 12345678910class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; out(A.size()); for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn &lt;= pp; --pos) &#123; out[pos] = pow(abs(A[pn]) &lt; abs(A[pp]) ? A[pp--] : A[pn++], 2); &#125; return out; &#125;&#125;; resultRuntime: 100 ms, faster than 98.97% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.3 MB, less than 100.00% of C++ online submissions for Squares of a Sorted Array. 执行效率和内存占用表现都相当好； tip后续类似循环的题目，最高的效率就是要在同一个循环里面，把多件事同时做了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-5]]></title>
    <url>%2F2019%2F04%2F21%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-5%2F</url>
    <content type="text"><![CDATA[ARTS week-5Algorithm[Leetcode]905. Sort Array By Parity Review23 great Pandas codes for Data Scientists 这周的review只算是勉强完成，后续会用扇贝对应的文章进行review Tipclose(0) 的坑 If fclose(0) is called, does this close stdin? 多线程的使用中，如果没有判断socket的文件描述符是否大于0，而直接close(0)，会导致不知名的崩溃，stackoverflow也有了对应的说明。 SharePyTorch 线性回归]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 线性回归]]></title>
    <url>%2F2019%2F04%2F21%2FPyTorch-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[线性回归线性回归是机器学习中最基本的模型，也是必须掌握的模型，其中涉及到最小二乘法，均方误差等，目的就是求得一条直线拟合一些点，首先生成如下图片的点，下面会用pytorch代码实现直线的拟合。 PyTorch代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import torchimport numpy as npimport torch.nn.functional as Fimport matplotlib.pyplot as plt# y = 5.2x+3 一元线性函数，斜率 5.2，截距3true_w = 5.2true_b = 3x = torch.unsqueeze(torch.linspace(-2, 2, 100), dim=1)y = true_w*x + true_b# 为y值增加高斯噪音，弄得像随机的，等下拟合出一条直线来回归这些点y = y + torch.randn(x.size()) # 打印散点图plt.scatter(x.data.numpy(), y.data.numpy())plt.show()# plt更新plt.ion()plt.show()# 定义一个线性回归的类，继承于Moduleclass LinearRegression(torch.nn.Module): def __init__(self): super(LinearRegression, self).__init__() self.linear = torch.nn.Linear(1, 1) # 线性模型，一个输入，一个输出 def forward(self, x): return self.linear(x) model = LinearRegression()# 均方误差损失loss_function = torch.nn.MSELoss()# 随机梯度下降，学习率 1e-3optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)# 另外一个优化方法 Adam#optimizer = torch.optim.Adam(model.parameters(), lr=2e-2)# 迭代次数 2000epochs_num = 2000for epoch in range(epochs_num): # forward out = model(x) loss = loss_function(out, y) # backward optimizer.zero_grad() # 梯度还原为零 loss.backward() # 反向传播 optimizer.step() # 更新参数 if (epoch+1) % 20 == 0: # print('Epoch[&#123;&#125;/&#123;&#125;], loss: &#123;:.6f&#125;'.format(epoch+1,epochs_num,loss.data.item())) plt.cla() plt.scatter(x.data.numpy(), y.data.numpy()) plt.plot(x.data.numpy(), out.data.numpy(), 'r-', lw=5) plt.text(-2, 12, 'Loss=%.4f' % loss.data.numpy(), fontdict=&#123;'size':15, 'color':'red'&#125;) plt.pause(0.1)plt.ioff()plt.show() 可以调整学习率、迭代次数、优化方法，看看不同的调整，会有什么不同的结果 学习率太小，可能导致迭代速度过慢，迭代次数结束后，损失还很大 学习率太大，可能导致无法收敛，并出现振荡，迭代结束后，损失依然大 Adam使用的学习率与SDG使用的学习率并不一定会一样 最后拟合出来的图像如下图： 代码也可以查看我的GitHub仓库LinearRegression，如有错误，欢迎指出。]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PyTorch</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]905. Sort Array By Parity]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-905-Sort-Array-By-Parity%2F</url>
    <content type="text"><![CDATA[905. Sort Array By ParityGiven an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Example 1: 123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 题目解析：将奇偶数排序，偶数在前，奇数在后，偶/奇数内部无需关心排序； 方案一思路：一个数组，遍历数组，新建一个vector用于返回，偶数在前面插入，奇数在后面插入； 1234567891011121314class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; out; for (const int item: A) &#123; if (item % 2 == 0) &#123; out.emplace(out.begin(), item); &#125; else &#123; out.emplace_back(item); &#125; &#125; return out; &#125;&#125;; resultRuntime: 64 ms, faster than 10.14% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.9 MB, less than 98.71% of C++ online submissions for Sort Array By Parity. 执行时间太多了！怎么这么慢 方案二 返回的数组大小也是固定的，初始化固定长度的vector； 循环迭代的同时赋值，对应index++或者index—； 其中 &amp; 运算和 % 运算，从效率上来说并没有差别，换了之后也差不多； 123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; int len = A.size(); vector&lt;int&gt; out(len); for (int i = 0, begin_out = 0, end_out = len - 1; i &lt; len; i++) &#123; if (A[i] &amp; 1) &#123; out[end_out--] = A[i]; &#125; else &#123; out[begin_out++] = A[i]; &#125; &#125; return move(out); &#125;&#125;; resultRuntime: 28 ms, faster than 98.35% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.7 MB, less than 99.36% of C++ online submissions for Sort Array By Parity. 方案三高手在民间，网友出绝招，讨论区的解决方案，效率上差不多，就是相当简洁。 12345678class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; auto is_even = [] (auto e) &#123; return e % 2 == 0; &#125;; partition (A.begin (), A.end (), is_even); return A; &#125;&#125;; resultRuntime: 28 ms, faster than 98.35% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.6 MB, less than 99.36% of C++ online submissions for Sort Array By Parity.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-4]]></title>
    <url>%2F2019%2F04%2F14%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-4%2F</url>
    <content type="text"><![CDATA[ARTS week-4Algorithm [Leetcode]804. Unique Morse Code Words [Leetcode]929. Unique Email Addresses [Leetcode]595. Big Countries ReviewData scientist: The sexiest job of the 22nd century 决策者需要知道数据科学家能做什么，而不是数据科学家什么都能做，首先应该避免以下问题： 毫无技术领导力； 没数据就别谈效果，巧妇难为无米之炊； 垃圾透顶的工具（开发工具、开发语言、运行平台等）； 如果什么事都由你来做，那也就不是纯粹的数据科学家了； 关于工具和平台，应该是个完善的体系，而不是玩具，也不是说买买买就一定好用，适合更重要； 从设计师的视角看问题； 千万不要在一家没有数据的公司成为数据科学家； 为什么作者说数据科学家是22世纪最性感的工作，而不是现在？可能是这个世纪对数据科学家太不“友好”了。 Tip超级剪切板Ditto，windows下的剪切板神奇，历史拷贝都会保存，还能包含图片，文档等，极力推荐。 ShareC++ remove erase 用法浅析]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ remove erase 用法浅析]]></title>
    <url>%2F2019%2F04%2F12%2FC-remove-erase-%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[C++ remove erase 用法浅析remove 用法浅析写这篇浅析完全是意料之外的，只怪才疏学浅。 刷[Leetcode]929. Unique Email Addresses的时候不能用boost库，一脸懵逼，为了去除整个字符串中的“.”，boost库中就是一句话boost::erase_all(str, ‘.’)，但是stl库中没有现成的接口可以使用，求助Google，发现了erase和remove结合使用可以达到目的； 1local.erase(remove(local.begin(), local.end(), '.'), local.end()); // 删除local字符串中所有的'.' 但是这样的用法没玩过，不是特别好理解，写个demo验证下，先看代码： 123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string str = "helloworld"; cout &lt;&lt; "before remove: " &lt;&lt; str &lt;&lt; endl; string::iterator ret_end = remove(str.begin(), str.end(), 'o'); // remove字符串中所有的‘o’，此时并没有真正删除 cout &lt;&lt; "after remove: " &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; "ret_end: "; for (string::iterator i = str.begin(); i &lt; ret_end; i++) &#123; cout &lt;&lt; *i; // 这里打印的结果是从str的开头，到截止remove返回的应该结束的位置； &#125; cout &lt;&lt; endl; str = "helloworld"; cout &lt;&lt; "before erase: " &lt;&lt; str &lt;&lt; endl; str.erase(remove(str.begin(), str.end(), 'o'), str.end()); cout &lt;&lt; "after erase: " &lt;&lt; str &lt;&lt; endl; return 0;&#125; 先看下输出结果： 12345before remove: helloworldafter remove: hellwrldldret_end: hellwrldbefore erase: helloworldafter erase: hellwrld 具体看下remove的接口，cpluscplus手册上的链接std::remove 12template &lt;class ForwardIterator, class T&gt; ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val); 输入三个参数：迭代器起始，迭代器结束，要移除的值； 返回：迭代器，指向未移去的最后一个元素的下一个位置； 手册里面有一句解释： The range between first and this iterator includes all the elements in the sequence that do not compare equal to val. [first return)之间（不包含return指定的元素，到前一个截止），包含的是所有和val不等的元素，如上面demo中ret_end所示： ret_end: hellwrld // first到ret_end包含所有不等于 ‘o’ 的序列, ret_end则指向的是‘ld’之后的那个‘l’ remove 实现其实remove的实现，手册里面也有描述，就是需要理解一下 12345678910111213template &lt;class ForwardIterator, class T&gt; ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator result = first; while (first!=last) &#123; if (!(*first == val)) &#123; // first不等于val时，result对应的值才会更新，并指向下一个元素 *result = move(*first); ++result; &#125; ++first; &#125; return result;&#125; 就到这。。顺便吐槽 一下csdn上面的一些帖子，看了好多篇，也没有说到点子上，还有解释错的，更是有抄错的。。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]595. Big Countries]]></title>
    <url>%2F2019%2F04%2F11%2FLeetCode-595-Big-Countries%2F</url>
    <content type="text"><![CDATA[595. Big Countries今天这道题，是个sql语句的题目，选出符合条件的数据； There is a table World 123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million. Write a SQL solution to output big countries’ name, population and area. For example, according to the above table, we should output: 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ 比较简单，select where就可以解决了； 1select name, population, area from World where area&gt;3000000 or population&gt;25000000; resultRuntime: 196 ms, faster than 82.98% of MySQL online submissions for Big Countries. 结果有点惊讶，这么简单的还会有更好的解决办法？讨论区看了一眼，发现这么一个语句： 1SELECT name, population, area FROM World WHERE area &gt; 3000000 UNION SELECT name, population, area FROM World WHERE population &gt; 25000000; 奇迹出现了？？ 并没有。。。执行完效率并没有好多少，半斤八两。 这个时候就Google一番，or 和 union差在哪里，以下几篇文章有点参考意义。 mysql 实战 or、in与union all 的查询效率 SQL Performance UNION vs OR Whether to use UNION or OR in SQL Server Queries 总的来说，性能差异并不是绝对的，都需要针对实际数据进行实际的测试与验证，其中有一点是关键，对于非索引字段，or是肯定胜过union了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]929. Unique Email Addresses]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode-929-Unique-Email-Addresses%2F</url>
    <content type="text"><![CDATA[929. Unique Email AddressesEvery email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain &#39;.&#39;s or &#39;+&#39;s. If you add periods (&#39;.&#39;) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (&#39;+&#39;) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one &#39;@&#39; character. All local and domain names are non-empty. Local names do not start with a &#39;+&#39; character. 大概解释一下题目： 邮箱地址中，本地名称部分可能包含“.”和“+”，其中“.”会直接被忽略掉，而第一个’+’之后，到‘@’之前，则会被截断； 输入：一个邮箱地址的数组； 输出：处理后的邮箱地址，不重复的有多少个； 方案一 local name 和domain name 分开处理，否则domain name的‘.’可能会被错误去除； local name中可能包含多个“+”和多个“.”，“+”比较好处理，后面的直接截断；但是多个“.”就必须循环处理了； 123456789101112131415161718192021class Solution &#123;public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; set&lt;string&gt; email_set; for (string &amp;email : emails) &#123; int atindex = email.find('@'); string local = email.substr(0, atindex); string domain = email.substr(atindex); int plusindex = local.find('+'); if (plusindex != string::npos) &#123; local.erase(plusindex, atindex-plusindex); &#125; if(local.find('.') != string::npos) &#123; local.erase(remove(local.begin(), local.end(), '.'), local.end()); &#125; email_set.insert(local+domain); &#125; return email_set.size(); &#125;&#125;; resultRuntime: 36 ms, faster than 87.14% of C++ online submissions for Unique Email Addresses.Memory Usage: 12.9 MB, less than 87.81% of C++ online submissions for Unique Email Addresses. 方案二：方案一效果不是特别好，local部分其实循环处理了两次，可以把整个字符串从头到尾每个字符判断一遍； 123456789101112131415161718192021222324252627class Solution &#123;public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; unordered_set&lt;string&gt; emails_set; for (const string&amp; email : emails) &#123; string out; bool at = false; bool plus = false; for (char c : email) &#123; if (c == '.') &#123; if (!at) continue; &#125; else if (c == '@') &#123; at = true; &#125; else if (c == '+') &#123; if (!at) &#123; plus = true; continue; &#125; &#125; if (!at &amp;&amp; plus) continue; out += c; &#125; emails_set.insert(std::move(out)); &#125; return emails_set.size(); &#125;&#125;; resultRuntime: 32 ms, faster than 97.73% of C++ online submissions for Unique Email Addresses.Memory Usage: 11.9 MB, less than 99.28% of C++ online submissions for Unique Email Addresses. 为了降低时间复杂度，降低空间复杂度，尝试各种方法，这一题提交了20次。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]804. Unique Morse Code Words]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-804-Unique-Morse-Code-Words%2F</url>
    <content type="text"><![CDATA[804. Unique Morse Code WordsInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &quot;a&quot; maps to &quot;.-&quot;, &quot;b&quot; maps to &quot;-...&quot;, &quot;c&quot; maps to &quot;-.-.&quot;, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..—…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 大概解释一下题目：摩斯码，26个小写字母各对应一串密码串，不同的英文单词可能出现同样的摩斯码； 输入：一个数组，数组中包含多个单词； 输出：单词转换成摩斯码后，总的摩斯编码类别有几种； 解题思路： 要得到不同的摩斯码，就是不能有重复的，就可以用集合(set)来存储转换后的摩斯码； 26个小写字母对应的摩斯码是固定的，就用数组直接初始化； 字母a对应的ASCII码为97，数组第一个元素的索引index为0，直接减去97即可得到对应的摩斯码编码； 循环遍历vector中的word，循环遍历word中的每一个字母； 代码如下： 123456789101112131415161718class Solution &#123;public: int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) &#123; string morse[26] = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; set&lt;string&gt; morse_set; string str_morse; for (string &amp;word : words) &#123; unsigned len = word.length(); for(unsigned i = 0; i &lt; len; ++i) &#123; unsigned index = (unsigned)(word[i]-97); str_morse.append(morse[index]); &#125; morse_set.insert(str_morse); str_morse.clear(); &#125; return morse_set.size(); &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for Unique Morse Code Words.Memory Usage: 8.7 MB, less than 100.00% of C++ online submissions for Unique Morse Code Words.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-3]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-3%2F</url>
    <content type="text"><![CDATA[ARTS week-3Algorithm[Leetcode]709. To Lower Case ReviewYour Productivity Hinges on How You Arrange Your Desk 你的工作效率取决于如何整理桌面 专注于实用 实践极简主义 基于你的工作和思考方式进行整理 要事放在最前面 实用多个屏幕 多一些绿色植物 适应“零桌面”习惯，保持整洁 将你的目标放在显眼的位置 放一张好看的照片 TipMac OS tags ，高效整理及访问文件或者文件夹； 最近频繁使用hexo blog 文件夹及对应的文章，还有一些整理过的文件夹，多级访问后，需要频繁点击鼠标，今天刚刚发现可以对不同的文件及文件夹进行Tag，打标签处理，将文件进行分类，快速访问。 Share[机器学习]线性回归公式推导]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习]线性回归公式推导]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[线性回归 公式推导线性回归是机器学习最基本的一个模型，接下来会写几篇各个模型的公式推导，后续再用代码实现下基本的模型运行。 矩阵表示数据集：D=\{(x_{1}, y_{1}),(x_{2}, y_{2}) \cdots (x_{m}, y_{m})\}​ x_{i} \in \mathbb{R^{n}}( n维)，y_{i} \in \mathbb{R}，i=1,2 \cdots m​ X=\begin{pmatrix} x_{1} & x_{2} & \cdots & x_{m} \end{pmatrix}^{T} =\ \begin{pmatrix} x^{T}_{1}\\ x^{T}_{2}\\ \vdots \\ x^{T}_{m} \end{pmatrix} =\begin{pmatrix} x_{11} & x_{12} & \cdots & x_{1n}\\ x_{21} & x_{22} & \cdots & x_{2n}\\ \vdots & \vdots & \ddots & \vdots \\ x_{m1} & x_{m2} & \cdots & x_{mn} \end{pmatrix}_{m*n}​Y=\begin{pmatrix} y_{1}\\ y_{2}\\ \vdots \\ y_{n} \end{pmatrix}_{n*1}，w= \begin{pmatrix} w_{1}\\ w_{2}\\ \vdots \\ w_{n} \end{pmatrix}_{n*1}​目标函数 f(x) = w^{T}X 其中，几个关键点需要注意： m表示样本数量，n 表示特征维度； W​ 的维度是和样本的特征维度一样的 默认情况下x_{i} 是列向量，但是样本矩阵X 中的每一个对应的样本是行向量； 另外可以增加一个偏置b，目标函数为f(x) = wx+b ，其中 w_{0} = 1, x_{0} =\begin{pmatrix} x_{01}\\ x_{02}\\ \vdots \\ x_{0n} \end{pmatrix}_{n*1}=b= \begin{pmatrix} b_{1}\\ b_{2}\\ \vdots \\ b_{n} \end{pmatrix}_{n*1} 这样表示后，其实f(x)=wx+b 也可以简化成f(x)=wx，x_{i}增加了一维而已，计算过程是不会有任何影响的，我们暂且使用f(x) = w^{T}X 来进行下述的推导。 损失函数： L( w) =\sum ^{m}_{i=1}\left\Vert w^{T} x_{i} -y_{i}\right\Vert ^{2}_{2} \\ =\sum ^{m}_{i=1}\left( w^{T} x_{i} -y_{i}\right)^{2}\\ =\begin{pmatrix} w^{T} x_{1} -y_{1} & w^{T} x_{2} -y_{2} & \cdots & w^{T} x_{m} -y_{m} \end{pmatrix}\begin{pmatrix} w^{T} x_{1} -y_{1}\\ w^{T} x_{2} -y_{2}\\ \vdots \\ w^{T} x_{m} -y_{m} \end{pmatrix}其中左边一项先做化简，右边相乘的是左边的转置： \begin{pmatrix} w^{T} x_{1} -y_{1} & w^{T} x_{2} -y_{2} & \cdots & w^{T} x_{m} -y_{m} \end{pmatrix} \\ =\begin{pmatrix} w^{T} x_{1} & w^{T} x_{2} & \cdots & w^{T} x_{m} \end{pmatrix} -\begin{pmatrix} y_{1} & y_{2} & \cdots & y_{m} \end{pmatrix}\\ =\ w^{T}\begin{pmatrix} x_{1} & x_{2} & \cdots & x_{m} \end{pmatrix} -\begin{pmatrix} y_{1} & y_{2} & \cdots & y_{m} \end{pmatrix}\\ =w^{T} X^{T} -Y^{T}\therefore \ L( w) =\left( w^{T} X^{T} -Y^{T}\right)\left( w^{T} X^{T} -Y^{T}\right)^{T}\\ =\left( w^{T} X^{T} -Y^{T}\right)( Xw-Y)\\ =w^{T} X^{T} Xw-w^{T} X^{T} Y-Y^{T} Xw+Y^{T} Y\\ =\ w^{T} X^{T} Xw-2w^{T} X^{T} Y+Y^{T} Y要求得损失函数L(w)的最小值所对应的w，就是求L(w)的导数为零的w的值； \frac{\partial L( w)}{\partial w} =2X^{T} Xw-2X^{T} Y=0\\ \therefore \ X^{T} Xw=X^{T} Y\\ \therefore w=\left( X^{T} X\right)^{-1} X^{T} Y今天先写到这，后续再更新下“几何解释”，未完待续… reference 线代随笔12-线性回归的矩阵推导 机器学习-白板推导系列-线性回归（Linear Regression） 最小二乘法-维基百科]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Machine Learning</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]709. To Lower Case]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode-709-To-Lower-Case%2F</url>
    <content type="text"><![CDATA[709. To Lower CaseImplement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. 题目很简单，说的就是英文字符串，转换成小写。 Example 1: 12Input: &quot;Hello&quot;Output: &quot;hello&quot; Example 2: 12Input: &quot;here&quot;Output: &quot;here&quot; Example 3: 12Input: &quot;LOVELY&quot;Output: &quot;lovely&quot; 方案一首先想到的就是遍历字符串，判断每一个字符是否是大写，如果是大写，则按照ASCII码，转换成小写后，添加到一个新的字符串里； 123456789101112131415class Solution &#123;public: string toLowerCase(string str) &#123; string out; for(char &amp;i : str) &#123; if ((i &gt;= 65) &amp;&amp; (i &lt;= 90)) &#123; i=i+32; out.push_back(i); &#125; else &#123; out.push_back(i); &#125; &#125; return out; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for To Lower Case. Memory Usage: 8.3 MB, less than 50.42% of C++ online submissions for To Lower Case. 结果看起来还可以，内存占用有点高，想着怎么优化一下； 方案二string out，占用了一个新建的字符串，是不是可以在原来的字符串里面修改？try try see. 12345678910111213class Solution &#123;public: string toLowerCase(string str) &#123; unsigned int len = str.length(); for(unsigned i = 0; i &lt; len; ++i) &#123; char ch = str[i]; if ((ch &gt;= 65) &amp;&amp; (ch &lt;= 90)) &#123; str[i]=ch+32; &#125; &#125; return str; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for To Lower Case. Memory Usage: 8 MB, less than 99.17% of C++ online submissions for To Lower Case. 内存占用降低了点，效果还可以。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-2]]></title>
    <url>%2F2019%2F03%2F31%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-2%2F</url>
    <content type="text"><![CDATA[ARTS week-2Algorithm[Leetcode]771.Jewels and Stones ReviewWhat I have learned after several AI projects 文章讲述了作者做AI项目的一些经验之谈 在进入AI浪潮之前，问自己三个问题： 你的业务是否是数据驱动 是否有合适并且有效的数据来支撑AI方案的实施 是否真正理解了AI是怎么工作的（如何产生效益） 小范围试错，没必要一开始就替换之前可以持续运行的系统，可能带来不可估量的损失； 知道自己想要什么，需要给AI一个明确的目标，这需要商业决策者和数据科学家共同理解并定义； AI项目的持续运行，除了架构、数据、算法外，更重要的是“人”，除了开发者，也包括使用这个AI系统，并给予真诚反馈的人； 数据集，并且是标注过的数据集，正确的数据集是关键； 基础设施：高性能的计算机，还有高带宽，高存储； AI是把双刃剑，能助你腾飞，也可能因此翻船。 Tip类Unix系统命令whatis，用来查询一个指定命令的简介信息，简要操作就像下面的动图一样。 Share读书笔记：《凤凰项目》（下）]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《凤凰项目》（下）]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书笔记：《凤凰项目》（上） 上一篇讲了主人公从四种工作类型中理顺了工作流程，接下来我们看看续集… 比尔不仅弄清了所有工作流程中的瓶颈所在，也认定了“凤凰项目”在一群毫无章法的人和毫无流程可言的IT运营下，是一定会失败的；但是，这一切CEO都不会承认，却还斩钉截铁地认为“凤凰项目”一定可以成功，并且因此拯救公司； 果然，凤凰项目上线后，不仅没有为公司带来现金流，却带来了更多的麻烦；董事会给了公司管理人员三个月的时间，否则将进行公司的拆分，并把IT的工作外包出去； 公司的董事及对应的管理人员，经过慎重的考虑后，抽掉了各个单位的精英人才，经过过IT流程的详细梳理与慎重思考，启动了新的“独角兽”项目，并从一开始就把开发与运维混合在一起进行工作，不再是原来的开发与运维分离，先开发、后运维的方式；更为疯狂的是，完成了一个零所有人的瞠目结舌的目标：一天部署10次。 在开发运维的过程中，所有能自动化的事情都自动化了，包含了：开发测试，环境部署，监控报警，所有能脱离人工的，都脱离了人工；这些流程上的优化，大大加快了开发运维的速度，也减少了中间出现的问题。 “独角兽”项目上线之后大获成功，公司现金流大增，不仅挽救了公司，也挽救了CEO，比尔也从此走上了人生的另一个领地，开始走上公司的更高层。 这个挽救公司的过程中，作者梳理出了三步工作法： 第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔，绝不让缺陷流向下游工作中心，并且不断为了整体目标（相对于开发功能完成率、测试发现/修复比率或运维有效性指标等局部目标）进行优化。 必要的做法包括持续构建、集成以及部署，按需创建环境，严控半成品，以及构建起能够顺利变更的安全系统和组织。 第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保防止问题再次发生，或者更快地发现和修复问题。这样，我们就能在所需之处获取或嵌入知识，从源头上保证质量。 必要的做法包括：在部署管道中的构建和测试失败时“停止生产线”；日复一日地持续改进日常工作；创建快速的自动化测试套装软件，以确保代码总是处于可部署的状态；在开发和IT运维之间建立共同的目标和共同解决问题的机制；建立普遍的产品遥测技术，让每个人都能知道，代码和环境是否在按照设定的运行，以及是否达到了客户的目标。 第三工作法是关于创造公司文化，该文化可带动两种风气的形成：不断尝试，这需要承担风险并从成功和失败中吸取经验教训；理解重复和练习是熟练掌握的前提。 尝试和承担风险让我们能够不懈地改进工作系统，这经常要求我们去做一些与几十年来的做法大不相同的事。一旦出了问题，不断重复的日常操练赋予我们的技能和经验，令我们可以撤回至安全区域并恢复正常运作。 必要的做法包括营造一种勇于创新、敢于冒险（相对于畏惧或盲目服从命令）以及高信任度（相对于低信任度和命令控制）的文化，把至少20%的开发和IT运维周期划拨给非功能性需求，并且不断鼓励进行改进。 推荐大家阅读《凤凰项目》，从中了解流程的优化，项目的进化，也看看作者的心路历程，可能有一天，你我都可能会经历类似的事情，共勉。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>项目管理</tag>
        <tag>技术管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]771.Jewels and Stones]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode-771-Jewels-and-Stones%2F</url>
    <content type="text"><![CDATA[771. Jewels and StonesYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 解释一下题目： 在第二个字符串中，找出在第一个字符串中出现的字符的个数，其中，第一个字符串中的字符是不重复的。 思路：对于是否在第一个字符中出现，可以把第一个字符串的字符当做一个集合，再去判断元素是否在集合中，两个循环即可解决。 123456789101112131415161718class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int size = J.length(); set&lt;char&gt; jewel_set; for (unsigned int i = 0; i &lt; size; ++i) &#123; jewel_set.insert(J[i]); &#125; int count = 0; size = S.length(); for (unsigned int i = 0; i &lt; size; ++i) &#123; if (jewel_set.count(S[i])) &#123; count++; &#125; &#125; return count; &#125;&#125;; resultRuntime: 8 ms, faster than 74.17% of C++ online submissions for Jewels and Stones. Memory Usage: 9.9 MB, less than 54.58% of C++ online submissions for Jewels and Stones. 代码再简洁优化下，使用C++11的for循环，并且增加const限定符，程序快了，内存占用也降低了。 123456789101112131415161718class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int size = J.length(); set&lt;char&gt; jewel_set; for (const char &amp;ch : J) &#123; jewel_set.insert(ch); &#125; int count = 0; size = S.length(); for (const char &amp;ch: S) &#123; if (jewel_set.count(ch)) &#123; count++; &#125; &#125; return count; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for Jewels and Stones. Memory Usage: 8.6 MB, less than 98.64% of C++ online submissions for Jewels and Stones.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-1]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-1%2F</url>
    <content type="text"><![CDATA[ARTS week-1Algorithm[Leetcode]21.Merge Two Sorted Lists ReviewI’m Leaving Google — Here’s the Real Deal Behind Google Cloud 作为一个已经离开Google的人，作者说了一些自己在谷歌云当项目经理的种种体会与感想；更是给了Google很高的评价，希望自己的三个儿子都可以在Google开始他们的职业生涯，因为Google提供了在大多数重要的科技领域中，快速学习与发展的机会。 Google是工程师和项目经理的天堂 高水平的工程师与项目经理，牛人聚集，从来不缺智慧与经验，创造着各种各样不可思议的产品，但是也绝对不会忽略员工的个人发展，有着很好的个人职业规划。 千金难买好文化 所有信息都是可以公开获得的，每周与创始人及高管的对话，另外之前也听说过，Google的代码对于所有入职员工都是可以随意访问的；同事之间的互助与合作很融洽，内部有各种不同的论坛，都能很及时的得到各种帮助。 融为一体的创新与规模 既有创新，有能将小小的创新最后做成规模化的产品服务大众。 以为Google只是这样止步以此？在AWS和AZure的夹击下，Google依然迎头赶上，做出了Google Cloud，通过大家的努力，也赢得了一些不同需求的客户，走在做强做大的道路上。 文章中出现的一些英文缩写，比如IMO，一开始并不知道什么意思，查了之后，才知道是In My Opinion的意思，附上查询英文缩写的网站 https://www.acronymfinder.com/ Tipssh指定端口及免密登录 去年4.1号用gcp搭的梯子，下周就过期了，这周新建了gcp进行梯子的搭建，将gcp默认的ssh端口22修改成了其他数字，在ssh命令后面增加-p参数，即可更改； 以前使用ssh时，都是使用用户名密码进行登录，但是gcp默认没有设置对应的密码，查过一番后，是可以免密登录的，创建对应的公钥和私钥，ssh命令后面增加-i参数，指定对应的私钥，在gcp的元数据中，增加对应的公钥，即可实现免密登录，拷贝私钥到不同的电脑上，还可以实现在多台电脑上能进行ssh的免密登录，后续维护vps也更方便了。 假设私钥是private-ssh-key，端口是12345，命令就类似下面这样，生成公钥、私钥对，使用“ssh-keygen”命令，具体再详细google或者查man手册。 1ssh -i private-ssh-key -p 12345 username@192.168.1.123 Share读书笔记：《凤凰项目》（一）]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《凤凰项目》（上）]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[《凤凰项目》讲述了一个IT运维的传奇故事，一位IT经理临危受命，经过多番努力，将公司从死亡边缘拉了回来。跌宕起伏的故事情节，也生动地描述了现代IT组织的管理过程中可能遇到的各种事件，服务中断、服务器崩溃、数据丢失、客户隐私数据泄露、办公室政治的博弈等等；想得到与想不到的事均穿插其中；但是从始至终有一条线很清晰，就是主人公一直在通过各种方法，来改善公司以往破旧不堪且岌岌可危的IT系统，以此来支撑公司的持续高效运营。 主人公比尔临时被推上了IT副总裁的位置，开始看到这个公司的IT管理的混乱不堪，一切都毫无章法，项目任务归属不清、IT变更没有记录、紧急状况没有预案、安全合规更是无稽之谈；他开始尝试梳理所有事情，让一切慢慢变得清晰起来， 列出目前所有项目，各个项目对应的事项 列出目前正在运维的项目 列出所有需要变更的事项 整理出了一堆表格与列表后，他终于有点摸清了整个IT运维的相关事情，并对各种项目做了优先级排列，需要变更的事项也根据优先级做了分类； 在这一切都有条不紊地进行时，却时不时出现不同原因导致的服务中断，相关人员不得不停下手上的工作，投入到救火的队伍中，此时，他发现自己漏了一个很大的工作事项，就是“计划外工作”，也可称为“救火的工作”，这时，他总算摸清了四种类型的IT运维工作，分别是： 业务项目（新项目部署、调试、上线） IT运维项目（已上线项目新增的运维任务） 变更任务（运维变更，bug修复变更，需求变更） 计划外工作（紧急bug，宕机，服务中断） 项目管理中的两大需要梳理清楚的东西： 人：有多少人，这些人能干什么事，能做多少事； 事：有多少事，这些事需要什么人来干，需要多少人来干； 另外还有一个很关键的因素穿插其中，那就是“时间”，时间是一个很魔幻的东西，毕竟有些事，不是有人就可以做得成的，有一个比较极端的例子就是：一个女人十月怀胎生出一个娃，但是千万别想让十个女人一个月生出一个娃。 在时间不够的情况下，如果没有办法加时间，那就要砍需求、去除部分非核心功能，如果功能不允许去除，那就得忍受项目上线有bug，而且可能是影响客户体验的bug；不可能在有限的时间里，既要实现功能，又要有质量保障，那就基本是不可能的事儿了，纯属天荒夜谈。 故事到这，讲了基本的四种工作类型是什么，过程中，注重的是理清流程、梳理任务、分门别类，为下一步工作做好铺垫。 接下来是力挽狂澜，顺风顺水，还是屡战屡败，越挫越勇，故事还没看完，下回接着讲…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>项目管理</tag>
        <tag>技术管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]21.Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 给定有序的两个数组，合并两个数组，并保持有序。这其实是归并排序的其中一个步骤。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1 == NULL &amp;&amp; l2 == NULL) return NULL; if(l1 == NULL &amp;&amp; l2 != NULL) return l2; if(l1 != NULL &amp;&amp; l2 == NULL) return l1; ListNode* result; if (l1-&gt;val &lt;= l2-&gt;val) &#123; result = l1; l1 = l1-&gt;next; result-&gt;next = mergeTwoLists(l1, l2); &#125; else &#123; result = l2; l2 = l2-&gt;next; result-&gt;next = mergeTwoLists(l1, l2); &#125; return result; &#125;&#125;; tip: 两个参数是否空指针需要判断 result提交过程错了两次，一次是因为空指针，一次是因为判断大小的语句里，还多余判断了一次下一个元素是不是空指针，导致少了个元素。 Runtime: 20 ms, faster than 9.56% of C++ online submissions for Merge Two Sorted Lists.Memory Usage: 9.9 MB, less than 88.65% of C++ online submissions for Merge Two Sorted Lists. 内存占用太大，还有改进空间。 有个疑惑，其中一段代码改成以下这样后，内存占用竟然升高到10.1M 1234567if (l1-&gt;val &lt;= l2-&gt;val) &#123; result = l1; result-&gt;next = mergeTwoLists(l1-&gt;next, l2); &#125; else &#123; result = l2; result-&gt;next = mergeTwoLists(l1, l2-&gt;next); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 内置数据结构（一）]]></title>
    <url>%2F2018%2F07%2F29%2FPython-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[从上一篇“Python入坑指北”开始，一系列的Python文章，是关于Python的学习笔记，参考书是《Python for Data Analysis, 2nd Edition》，github的仓库有详细的jupyter notebook（https://github.com/wesm/pydata-book）。 元组（tuple）1.1 初始化123456789# 初始化tup1 = 4, 5, 6print(tup1)tup2 = 'hello', [1, 3], (4, 6), 0.5, 1, 1==1, &#123;'a':1, 'b':2&#125;print(tup2)tup3 = tuple([4, 0, 2])print(tup3)print(tuple('string'))print(tuple(['foo', [1, 2], True])) 以上代码输出结果： 12345(4, 5, 6)('hello', [1, 3], (4, 6), 0.5, 1, True, &#123;'a': 1, 'b': 2&#125;)(4, 0, 2)('s', 't', 'r', 'i', 'n', 'g')('foo', [1, 2], True) 可以看出几个重要的点： 元素以逗号“,”分割，以括号( )包含一个元组的所有元素； 一个tuple里面可以同时容纳多种类型的元素，且不需要声明tuple类型 可以使用list进行tuple的初始化； 可以将一个string转化为tuple； 1.2 元素访问123456tup1 = tuple('string')print(tup1[0])tup2 = tuple(['foo', [1, 2], True])tup2[1].append(3)print(tup2)tup2[2] = False 以上代码输出结果： 123456s('foo', [1, 2, 3], True)Traceback (most recent call last): File "ch3_1.py", line 6, in &lt;module&gt; tup2[2] = FalseTypeError: 'tuple' object does not support item assignment 我们总结下访问的几个注意事项： 使用中括号 [ ] 进行元组元素的访问； 元组中元素只可读，不可写； == ，说好的元素只读，那上面代码的第4行是怎么回事，为什么还能添加一个元素？其实tup2[1]指向的是一个list，在这里是元素指向的list不可变，list本身是可以变更的。 1.3 元组的解包 (Unpacking tuple)12345678910111213141516171819202122232425tup = (4, 5, 6)a, b, c = tupprint(b)tup = (4, 5, (6, 7))a, b, (c, d) = tupprint(d)# 交换变量赋值a, b = 1, 2b, a = a, bprint(a, b)# 用于元组和数组的迭代解包seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]for a, b, c in seq: print('a=&#123;0&#125;, b=&#123;1&#125;, c=&#123;2&#125;'.format(a, b, c)) # 函数的多返回值values = 1, 2, 3, 4, 5a, b, *rest = valuesprint(a, b)print(rest)# 如果rest此时是不需要使用的变量，可以如下表示，使用‘_’当做占位符a, b, *_ = values 以上代码输出结果： 12345678572 1a=1, b=2, c=3a=4, b=5, c=6a=7, b=8, c=91 2[3, 4, 5] 元组的解包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接收这些元素的元组的空档数一致；也可以用*来表示忽略多余的元素（如上代码所述）； 一般的迭代对象包括：元组，列表，字典，字符串。 1.4 常用类方法如果在ipython中或者Jupyter notebook中，使用TAB键就能列出tuple的类方法，下面说几个常用方法； 123tup = (1, 2, 3, 3)tup.count(3) # 计算3在tuple中的个数tup.index(2) # 返回第一个2在tuple中的位置 列表（list）与tuple相比，list就是可变长的，可直接修改相应元素的对象，使用中括号 [] 进行初始化。 2.1 初始化 自定义初始化list 123456a_list = [2, 3, 7, None]tup = ('foo', 'bar', 'baz')b_list = list(tup)print(b_list)b_list[1] = 'peekaboo'print(b_list) 列表和元组在语法上有点类似，list可以直接从tuple初始化得到，两者之前最大的差异就是可修改与不可修改； 以上代码执行的结果如下，可以看到第5行代码修改了list的第二个元素 12['foo', 'bar', 'baz']['foo', 'peekaboo', 'baz'] list常用来实现一个迭代器或者生成表达式： 1234gen = range(10)print(gen)g_list = list(gen)print(g_list) 输出结果如下： 12range(0, 10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 2.2 添加和删除元素12345678910111213b_list = ['foo', 'bar', 'baz']b_list.append('dwarf') # 末尾添加元素print(b_list)b_list.insert(1, 'red') # 指定index添加元素print(b_list)b_list.pop(2) # 指定index删除元素print(b_list)b_list.append('foo') # 末尾添加元素print(b_list)b_list.remove('foo') # 删除第一个fooprint(b_list)print('dwarf' in b_list) # 判断dwarf是否在list中print('dwarf' not in b_list) 可以看到，添加元素有append, insert方法，删除元素有pop, remove方法，其他有关list的方法，可以在ipython中使用TAB键进行查看； 如果不考虑性能，可以使用append和remove，不然可以使用Python的另外一个数据结构 ‘multiset’，以此来优化性能； 输出结果： 1234567['foo', 'bar', 'baz', 'dwarf']['foo', 'red', 'bar', 'baz', 'dwarf']['foo', 'red', 'baz', 'dwarf']['foo', 'red', 'baz', 'dwarf', 'foo']['red', 'baz', 'dwarf', 'foo']TrueFalse 2.3 列表的拼接和组合1234print([4, None, 'foo'] + [7, 8, (2, 3)])x = [4, None, 'foo']x.extend([7, 8, (2, 3)]) # 已定义的list，使用extend进行扩展组合print(x) 以上代码输出结果： 12[4, None, 'foo', 7, 8, (2, 3)][4, None, 'foo', 7, 8, (2, 3)] 列表的拼接 “+” 会创建出一个新的对象并进行拷贝，如果构造了一个数据量大的列表，再对其进行copy操作，将会非常影响性能，此时建议使用extend进行扩展组合操作； 1234567everything = []for chunk in list_of_lists: everything.extend(chunk)# 上面这个操作肯定比下面这个要更快everything = []for chunk in list_of_lists: everything = everything + chunk 2.4 排序 排序 123456a = [7, 2, 5, 1, 3]a.sort()print(a)b = ['saw', 'small', 'He', 'foxes', 'six']b.sort(key=len) # 按元素长度排序print(b) 输出结果： 12[1, 2, 3, 5, 7]['He', 'saw', 'six', 'small', 'foxes'] 注意：列表排序并不需要重新创建对象，直接在原有对象上进行操作（in-place）； 二分查找与有序列表维护 Python内置 bisect模块实现了有序列表的二分查找和插入，看下以下几个操作： 123456import bisectc = [1, 2, 2, 2, 3, 4, 7]print(bisect.bisect(c, 2)) # the same of bisect_right 获取'2'这个元素在列表中即将插入的indexprint(bisect.bisect(c, 5))bisect.insort(c, 6) # the same of insort_rightprint(c) 注意： bisect 方法仅获取了index，并没有对元素进行插入操作； bisect模块并不会对list进行判断是否有序，所以，使用前需要进行排序，否则可能出现操作返回错误的结果； 以上代码执行结果： 1234 # 优先靠右，所以获取到的index为46[1, 2, 2, 2, 3, 4, 6, 7] 2.5 切片12345678910seq = [7, 2, 3, 7, 5, 6, 0, 1]print(seq[1:5]) # not included seq[5]seq[3:4] = [6, 3] # 替换 index 为 3,4 的两个元素为 6,3print(seq)print(seq[:5]) # start不填，默认从0开始print(seq[3:]) # start不填，默认到末尾print(seq[-4:]) # 倒数第4个开始，到末尾print(seq[-6:-2]) print(seq[::2]) # 正序，步长为2print(seq[::-1]) # 倒序，步长为1，the same of seq.reverse() [start:stop:step]，左闭右开，包含start开始的元素，不包含stop的元素 12345678[2, 3, 7, 5] [7, 2, 3, 6, 3, 5, 6, 0, 1][7, 2, 3, 6, 3][6, 3, 5, 6, 0, 1][5, 6, 0, 1][6, 3, 5, 6][7, 3, 3, 6, 1][1, 0, 6, 5, 3, 6, 3, 2, 7] 内置序列函数（Built-in Sequence Functions）Python包含三种主要的序列类型：list, tuple, range；还有其他的序列类型，包含二进制数据（binary data）和文本字符串（text strings）； 3.1 enumerate按照以往循环一个列表可能的操作是下面这样： 1234i = 0for value in collection: do something with value i += 1 Python内置了枚举操作，并返回对应的index和value： 12345some_list = ['foo', 'bar', 'baz']mapping = &#123;&#125;for i, v in enumerate(some_list): mapping[v] = iprint(mapping) # &#123;'bar': 1, 'baz': 2, 'foo': 0&#125; 3.2 sorted12print(sorted([7, 1, 2, 6, 0, 3, 2]))print(sorted('horse race')) 数字默认从大到小排序，字符串默认字母顺序排序 12[0, 1, 2, 2, 3, 6, 7][' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's'] 3.3 zipzip将两组或者多组可迭代的对象打包成一对对的元组 1234567seq1 = ['foo', 'bar', 'baz']seq2 = ['one', 'two', 'three']zipped = zip(seq1, seq2)list(zipped) # [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]seq3 = [False, True]# 打包出来的大小取决于最小的序列大小，即为2list(zip(seq1, seq2, seq3)) # [('foo', 'one', False), ('bar', 'two', True)] 两种常用的zip方法： 12345678910111213# 与enumerate结合for i, (a, b) in enumerate(zip(seq1, seq2)): print('&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'.format(i, a, b))# 0: foo, one# 1: bar, two# 2: baz, three# 解包(unzip)的另一种操作，也可进行数据的行列相互转换pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'), ('Schilling', 'Curt')]first_names, last_names = zip(*pitchers)first_names #('Nolan', 'Roger', 'Schilling')last_names #('Ryan', 'Clemens', 'Curt') 3.4 reversed1list(reversed(range(10))) # 序列翻转 注意：reversed是个生成表达式(generator)，需要搭配list或者for循环使用，reversed()本身返回的是一个迭代器对象。 下一篇文章会介绍一下其他的内置数据结构，包含字典（dict）、集合（set），以及他们和list的对比；才疏学浅，如有错误，还望联系并指出。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 入坑指北]]></title>
    <url>%2F2018%2F07%2F11%2FPython-%E5%85%A5%E5%9D%91%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[Python 入坑指北 1. 几个问题 2. 环境相关 2.1 Anaconda 2.2 IPython 2.3 Jupyter Notebook 3. Python语言基础 4. 思维导图 Python 入坑指北1. 几个问题 使用Python2 还是Python3？ 为什么安装Python package的时候出现各种莫名其妙的错误？ 怎么增加一个第三方的package，很多包还有多级的依赖关系，如何更好解决？ 2. 环境相关2.1 Anaconda什么是Anaconda，有什么优点？ Anaconda 是python的一个发行版，包含了conda、python和大量的数据科学相关的库，官方网站的主标题是：The Most Popular Python Data Science Platform； 其中Conda是一个管理工具，可以管理多种语言的包、依赖和环境；包含Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN；如果开发中需要同时使用Python2和Python3，Conda可以轻松帮你搞定不同版本之间的环境切换，也可轻松管理不同版本的包，这下安装包的时候就so easy，再也不会出现特别多的莫名其妙的错误了； Anaconda包含了Conda、Python和大量的数据科学相关的库，如果不需要那么多库，也可以选择Miniconda进行安装； 123456789101112# 安装一个packageconda install pkg_name# 同时安装多个packageconda install numpy scipy pandas# 安装指定版本的packageconda install numpy=1.10# 移除一个packageconda remove pkg_name# 升级conda update# 查看所有packageconda list 下面再看下用conda管理不同的python版本环境； 12345678910111213141516# 创建一个python2.7版本的环境并安装pandas包conda create -n py2 python=2.7 pandas# 执行后你会发现，conda自动帮你把所有pandas依赖的包都装好了# 进入py2环境（windows使用 activate py2)source activate py2# 退出当前环境（windows使用 deactivate)source deactivate# 删除环境conda env remove -n py2# 列出所有创建的环境conda env list# 如果分享python代码需要分享同样的开发环境的时候，可以讲当前环境导出conda env export &gt; environment.yaml# 从YAML文件创建环境conda env create -f environment.yaml 环境相关的内容就到此，有了Anaconda，基本就不用再操心所谓的版本冲突问题，包安装问题，集成好的管理环境，也就不再需要烦恼环境问题，把精力耗费在写代码吧。 2.2 IPythonIPython是一种基于Python的交互式解释器；相较于原生的Python Shell，IPython提供了更为强大的编辑和交互功能。拥有诸多优点： 帮助信息完善，且支持模糊匹配（print?, print??, np.*load*?）；对象后面添加问号，一样能列出相关信息（称为对象的内省）； 支持TAB补全代码，使用历史输入（%history/%hist/hist命令） %run运行外部python脚本，%load加载外部python脚本，%paste运行剪贴板内容； 支持shell的终端快捷键； magic command（%timeit, %debug?, %pwd, etc…）； %matplotlib inline 可视化图内置显示； 2.3 Jupyter NotebookJupyter Notebook （此前被称为 IPython notebook）是个开源的Web应用，可以创建和分享包含代码、方程式、可视化界面和文本的文档，拥有以下优点： 可选择的语言：支持运行40 多种编程语言，包含Python、R、Julia、Scala等； 分享文档：可通过邮件、Dropbox、Github、Jupyter Notebook Viewer分享创建的文档； 交互式输出：代码可以生成丰富且带交互式的输出结果，包括HTML、图片、视频、LaTeX还有自定义的MIME格式； 大数据集成：通过Python、R或者Scala，使用例如Apache Spark等大数据工具，使用pandas、scikit-learn、 ggplot2、TensorFlow等对同一份数据进行处理； Jupyter Notebook 还有很多可以探寻的功能，比如可以远程访问等，具体操作慢慢探索。 jupyter notebook —no-browser 启动时不自动启动浏览器 jupyter notebook —generate-config 生成配置，修改访问IP，增加密码登录等 3. Python语言基础 缩进分割（4个空格），不像C++、Java使用分号分割每一个执行语句 没有括号，循环及控制语句使用冒号(:) 不建议赋值语句写在同一行，例如a = 5; b = 6; c = 7 一切皆对象 注释：使用#开头 动态数据类型，a=5，在不用重新声明的情况下，a=’foo’也是对的 强类型，a=5;b=’5’; a+b就会报错，在弱类型语言中(php,js,perl)会进行隐式转换 可变和不可变对象 可变对象 lists dicts NumPy arrays 不可变对象 string tuples 标量/原子类型 None str ‘hello’ “world” 多行使用’’’或者””” bytes Bytes Unicode float 除法：3/2=1.5, 3//2=1 bool True False int 类型转换 Dates and times 控制流 if, elif, and else for loops for value in collection: for a,b,c in iterator: while loops pass range 三元表达式(Ternary expressions) value = true-expr if condition else false-expr 内置函数 __builtin__ 查看所有内置函数 dir(__builtin__) 查看某个类的内置方法 dir(list) dir(tuple) 4. 思维导图以上内容整理简介的思维导图，以供后续复习：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计那些事]]></title>
    <url>%2F2018%2F06%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[概述数据库设计作为DBA的重要一课，也是作为开发人员认识数据库的一个基本课程，在左耳朵耗子的极客时间课程里，推荐了慕课网的《数据库设计那些事》，此文是学习的总结，画了完整的一个思维导图，如有错误，还望联系并指出。 思维导图]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库设计</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之路(一)数组和元组]]></title>
    <url>%2F2018%2F04%2F15%2FPython%E4%B9%8B%E8%B7%AF(%E4%B8%80)%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Python作为一种解释型语言，拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。从1991年第一个版本发布，到如今驰骋编程语言界近三十载，最近更是如火如荼，特别是这一波人工智能的兴起，将原本已经横跨多个领域（web开发，GUI开发，数据分析，数据可视化，人工智能）的Python，推向了一个新高度。 废话不多说，按 Linus 的话说： Talk is cheap, show me the code. 以下相关代码均在Python3.6环境下验证通过。 1234567891011121314151617181920#可使用不同的类型进行数组的初始化，无需像C++/Java必须同种类型才能同属一个数组my_list = [1, 3, 5, 7, "hello", 'one', 3.14] li = [1,2,3] # 初始化li.append(4) # 在数组最后添加一个元素4for item in li:print(item)print('========')for i in range(len(li)):print(li[i])print('========')print(li[0]) # 打印数组的第一个元素1print(li[1]) # 打印数组的第二个元素2print(li[-1]) # 打印数组的最后一个元素4li.append([5,6]) # 将[5,6]数组当做一个整体添加到数组最后print(li[-1]) # 打印数组最后一个元素 [5,6]li.extend([7,8]) # 将[7,8]数组内元素展开并添加到li中，而不是将[7,8]当做一个元素print(li[-1]) # 打印数组最后一个元素 8 输出结果： 1234567891011121314151234========1234========124[5, 6]8 上面一段代码列了基本的数组操作，访问元素，循环输出，其中li[-1]这种特殊的访问方式，在C/C++和Java中是没有的，可以从另一个方面理解，就是li[len(li) - 1]，只不过省略了len(li)。 接下里看下和数组有很多相似的元组tuple使用括号 () 进行初始化，只可读，不可写123456tp = (1, 3, 5, 'hello', 5.5, "one")print(tp)t = ('a', 'b', ['A', 'B'])t[2][0] = 'X't[2][1] = 'Y'print(t) 输出结果： 123(1, 3, 5, &apos;hello&apos;, 5.5, &apos;one&apos;)(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 说好的只读呢，这里应该理解成元素指向的不可变，第2个元组指向还是一个数组，只不过是数组内部元素发生了改变。 今天就到这。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集和字符编码]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[历史与渊源：当计算机由美国人发明后，当时设计到字符输入，由于是英文字符，通过收集整理。他们形成了标准的ASCII码(128) 字符集。8位，首位为0。由于不断普及，欧洲西方国家相应使用，发现有些特殊字符它们不能表示，如：λφ等。如是出来想法，想利用 ASCII 码后128位，增加它们的字符。这样就出现了EASCII码。这些还是不能表示所有国家，像法语，俄语等有自己特殊字符。因此制定标准将后128位进行分片制定。制定出iso-8859系列字符集。 ISO/IEC 8859-1 (Latin-1) - 西欧语言ISO/IEC 8859-2 (Latin-2) - 中欧语言ISO/IEC 8859-3 (Latin-3) - 南欧语言。世界语也可用此字符集显示。ISO/IEC 8859-4 (Latin-4) - 北欧语言ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言ISO/IEC 8859-6 (Arabic) - 阿拉伯语ISO/IEC 8859-7 (Greek) - 希腊语ISO/IEC 8859-8 (Hebrew) - 希伯来语（视觉顺序）ISO 8859-8-I - 希伯来语（逻辑顺序）ISO/IEC 8859-9（Latin-5 或 Turkish）- 它把Latin-1的冰岛语字母换走，加入土耳其语字母。ISO/IEC 8859-10（Latin-6 或 Nordic）- 北日耳曼语支，用来代替Latin-4。ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。ISO/IEC 8859-13（Latin-7 或 Baltic Rim）- 波罗的语族ISO/IEC 8859-14（Latin-8 或 Celtic）- 凯尔特语族ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元（€）符号。ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。 整出了这么多的字符集，说到底还是不够用；当计算机在中日韩等国家兴起的时候，这些字符集面对成千上万的中日韩字符，就显得有点力不从心了，像中国常见汉字有7000多个，扩展128个空位，完全不够。因此，需要用多个字节表示。后来就约定，第一个字节，第一位如果是1，后面还有一个字节与之一起表示一个字符。如果是0，就对应 ASCII 码。这样就形成了国内的GB2312，后来还是不够表示繁体中文，加入了繁体的字符形成了GBK；在GBK的基础上，又增加了6351个字符，其中一部分为4字节字（four-byte encoding range），增加了六种少数民族语言和一些四字节字，形成了GB18030-2000。但是，这样全世界各个国家还是用它们自己字符集进行表示。没有一个统一的大字符集，能够表示全球所有字符。 在 1991 年，国际标准化组织和统一码联盟组织各自开发了 ISO/IEC 10646（USC）和 Unicode 项目。各自都想将项目作为世界标准，不过很快双方都意识到世界上并不需要两个不兼容的字符集。于是他们就编码问题进行了一次非常友好地会晤，决定彼此把工作内容合并，项目依然独立存在，各自发布各自的标准，前提是两者必须保持兼容。不过由于 Unicode 这一名字比较好记，因而它使用更为广泛，成为了事实上的统一编码标准。 此时此刻，世界就如大家想像般地合并了，天下大一统。 Unicode与USCUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。 UTF-32/ UTF-16/ UTF-8 都是将数字转换到程序数据的编码方案。 我们平常所说的Unicode，通常是指Unicode字符集；从另一个层面来说，Unicode还有它的编码方案，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。 说完Unicode，就得再谈一下USC和Unicode的关系； Unicode 字符编码标准与 ISO 10646 的通用字符集（Universal Character Set，UCS）概念相对应，目前的用于实用的 Unicode 版本对应于 UCS-2，即使用16位来表示一个Unicode字符。也就是每个字符占用2个字节。这样理论上一共最多可以表示65,536(2的16次方) 个字符。基本满足各种语言的使用。实际上目前版本的 Unicode 尚未填充满这16位编码，保留了大量空间作为特殊使用或将来扩展。未来版本会扩充到 ISO 10646-1 实现级别3，即涵盖 UCS-4 的所有字符。UCS-4 是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示2,147,483,648(2的31次方)个字符，完全可以涵盖一切语言所用的符号。 UTFUTF：Unicode（UCS）只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字“严”的unicode（UCS）码是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。为了解决这些问题，就出现了UTF。 UTF（Unicode Translation Format），它是Unicode （UCS）的实现（或存储）方式，称为Unicode转换格式。Unicode 的实现方式不同于编码方式。一个字符的Unicode 编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。UTF有三种实现方式： UTF-16：其本身就是标准的Unicode编码方案，又称为UCS-2，它固定使用16 bits(两个字节)来表示一个字符。 UTF-32：又称为UCS-4，它固定使用32 bits(四个字节)来表示一个字符。 UTF-8：最广泛的使用的UTF方案，UTF-8使用可变长度字节来储存Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。UTF-8更便于在使用Unicode的系统与现存的单字节的系统进行数据传输和交换。与前两个方案不同：UTF-8以字节为编码单元，没有字节序的问题。 UTF有三种方案，那么如何在接收数据和存储数据时识别数据采用的是哪个方案呢？Unicode（UCS）规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte order Mark。 在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”（零宽度非换行空格）的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不会出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。Windows就是使用BOM来标记文本文件的编码方式的。 这样根据识别前面的”ZERO WIDTH NO-BREAK SPACE”字符即可识别编码方案，字节流中前几个字节所表示的编码方式如下： EF BB BF ———— UTF-8 FE FF ————UTF-16/UCS-2, little endian FF FE ————UTF-16/UCS-2, big endian FE FF 00 00 ————UTF-32/UCS-4, little endian. 00 00 FF FE ————UTF-32/UCS-4, big-endian. 实例大 Unicode编码为0x5927，可以通过Unicode中文编码表查到，用LoveString查看就是下图的结果： 在Ubuntu中用Python查看，如下图： 最后我们将单个中文字‘大’，用编辑器存储成不同的编码格式，再仔细看看对应的二进制： 图中显示的BOM字符，就是按照上述所说的顺序来显示了。 以上就是关于字符集和字符编码的整理与个人理解，不一定完全正确，如果有什么错误的地方，还望海涵并指出，互相学习，积极思考。 Reference字符集和字符编码（Charset &amp; Encoding） 字符集与字符集编码简介 wiki Unicode 百度百科 Unicode Byte order mark 阮一峰老师文章的常识性错误之 Unicode 与 UTF-8]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>字符集</tag>
        <tag>字符编码</tag>
        <tag>UTF8</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之豆瓣电影TOP250]]></title>
    <url>%2F2017%2F02%2F18%2FPython%E7%88%AC%E8%99%AB%E4%B9%8B%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250%2F</url>
    <content type="text"><![CDATA[学习爬虫的最初始原因是为了抓取一些想要的信息，也是为了后续学习机器学习相关内容积累一些数据处理方面的知识；废话不多说，上代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# __author__ = 'c1rew'# -*- coding: utf-8 -*-import requestsfrom bs4 import BeautifulSoupimport reimport timeimport pymysql.cursorsheader = &#123;'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36'&#125;urls = ['https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(str(i)) for i in range(0, 250, 25)]movies = []def parse_one_movie(cursor, infos): url = infos.find("a", href=re.compile(r"https://movie\.douban\.com/subject/[0-9]+/"))['href'] titles = infos.findAll("span", class_="title") title = "" if isinstance(titles, list): for item in titles: title = title + item.get_text() else: title = titles.get_text() other_title = infos.find("span", class_="other").string[3:] # delete / and space rating_num = infos.find("span", class_="rating_num").string movie_info = infos.find("div", class_="bd").p.get_text().strip() movie_infos = movie_info.split('\n') director_actor = movie_infos[0].strip() other_infos = movie_infos[1].strip().split('/') if len(other_infos) == 3: year = other_infos[0].strip() region = other_infos[1].strip() movie_type = other_infos[2].strip() else: # for 82 大闹天宫 year = other_infos[0].strip() +"," + other_infos[1].strip() + "," + other_infos[2].strip() + "," + other_infos[3].strip() region = other_infos[4].strip() movie_type = other_infos[5].strip() introduce = infos.find("span", class_="inq") # 有电影的简介是空的，这里容错下 if introduce != None: introduce = introduce.string else: introduce = "" movie = [title,\ other_title,\ url,\ rating_num,\ director_actor,\ year,\ region,\ movie_type,\ introduce] movies.append(tuple(movie))def get_url_info(cursor, url): url_info = requests.get(url, header) content = url_info.content.decode('utf-8') soup = BeautifulSoup(content, "html.parser") items = soup.findAll("div", class_="item") for item in items: parse_one_movie(cursor, item) time.sleep(1) # 一次网页请求间隔1m，防止被禁sql_create = "CREATE TABLE IF NOT EXISTS douban_top_movie " \ "( ID INT NOT NULL AUTO_INCREMENT, " \ " PRIMARY KEY(ID), " \ " title VARCHAR(128), " \ " other_title VARCHAR(128), " \ " url VARCHAR(512), " \ " rating_num VARCHAR(64), " \ " director_actor VARCHAR(1024), " \ " year VARCHAR(64), " \ " region VARCHAR(128), " \ " movie_type VARCHAR(128), " \ " introduce VARCHAR(1024)" \ ");"# 连接本地mysql数据库，mysql.server需要保证已启动connection = pymysql.connect(host='localhost', user='root', password='', db='douban_infos_db', charset='utf8mb4')try: with connection.cursor() as cursor: cursor.execute(sql_create) #从list中获取一个网页，一次解析25个电影 for url in urls: print(url) get_url_info(cursor, url) sqlcmd = '''insert into douban_top_movie ( title, other_title, url, rating_num, director_actor, year, region, movie_type, introduce ) values(%s, %s, %s, %s, %s, %s, %s, %s, %s)''' cursor.executemany(sqlcmd, movies) connection.commit()finally: connection.close() 代码运行环境： Python 3.5.2 |Anaconda 4.2.0 (x86_64) Mac mini macOS Sierra Version 10.12.2 如果本地运行环境不一致，可能会出现一些错误，到时候再对应调整一下，如果不用MySQL存储数据，也可以使用Redis或者Excel表格也行。 MySQL相关命令行中使用sql语句导出时，MySQL报错了：1The MySQL server is running with the --secure-file-priv option so it cannot execute this statemen google了一番，发现是MySQL的配置问题，需要修改/etc/my.cnf 如果这个目录下没有这个文件，就到MySQL的安装目录下去拷贝默认的一份配置，我的Mac是在下面的路径里： /usr/local/Cellar/mysql/5.7.17/support-files/my-defalult.cnf 拷贝过去后，在my.cnf的最后增加一句 secure_file_priv=”” 接下来再使用sql语句将之前已入库的数据导出csv表格，以便后续上传到BDP做简单的数据统计分析 12345SELECT * FROM douban_top_movie INTO OUTFILE '~/work/topmovie.csv' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n'; 数据分析仅仅挑选了几个比较好展示的数据，没有对类型进行分词处理，不然是可以对类型做一个饼图，这样效果是会好一些； Reference写这个代码的过程中，参考了一些类似资料，也是在学习Python爬虫课的过程中记录下练习过程； 推荐下七月在线的课，打折的时候还是有很多优惠：七月在线 （PS: 无利益相关哈！！） 以下是一些参考链接： python爬虫之豆瓣音乐top250 Python爬虫之Xpath学习 Python MySQL数据库操作]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率为0的事件，必然不能发生吗？]]></title>
    <url>%2F2016%2F10%2F09%2F%E6%A6%82%E7%8E%87%E4%B8%BA0%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%BF%85%E7%84%B6%E4%B8%8D%E8%83%BD%E5%8F%91%E7%94%9F%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[记录下这个概率的经典问题，理解还是不够透彻，把大家的讨论与理解记录下。概率为 0 的事件，必然不能发生吗？概率为 1 的事件，必然能发生吗？（知乎） 概率为 0 的事件，必然不能发生吗？（豆瓣） 一个简单却又很多人搞错的数学概念 关于概率为0的事件和不可能事件 与测度相关，相对较难测度（维基百科） 概率与测度 测度论与概率论基础]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>概率论</tag>
        <tag>数理统计</tag>
        <tag>测度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核子系统]]></title>
    <url>%2F2016%2F10%2F07%2FLinux%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Linux 内核子系统Linux 内核可分为 5 个子系统，包括：进程调度、内存管理、虚拟文件系统、网络、进程间通信； 进程调度（Process Scheduler），也称作进程管理，进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。 内存管理（Memory Manager），负责管理内存资源，提供虚拟内存机制； 虚拟文件系统（Virtual File System）,隐藏了硬件的具体细节，为所有的外部设备提供了统一的操作接口（open, read, write, close）； 网络（Network），网络子系统，负责管理系统的网络设备，其中也包含了网络协议与网络设备驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序； 进程间通信（IPC：Inter-Process Communication），包含多种进程间通信的方法，包括：信号量、共享内存、管道等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。 Reference 【Linux技术】嵌入式linux内核的五个子系统 Linux内核的整体架构]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
        <tag>子系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera-Machine Learning 之 Logistic Regression (逻辑回归)-0x02]]></title>
    <url>%2F2016%2F10%2F05%2FCoursera-Machine-Learning-%E4%B9%8B-Logistic-Regression-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-0x02%2F</url>
    <content type="text"><![CDATA[原文首发于个人CSDN博客：http://blog.csdn.net/kalenzh/article/details/43817321 Cost FunctionTraining set(训练集):$\{(x^{(1)}, (y^{(1)}), (x^{(2)}, (y^{(2)}), ... ,(x^{(m)}, (y^{(m)})\}$ m 个训练样本 $$x \in \begin{bmatrix} x_0\\ x_1\\ ...\\ x_n\\ \end{bmatrix} \space x_0 = 1, y \in \{0,1\}$$ $h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$ 如何选择拟合参数 $\theta$ ? 代价函数 线性回归：$J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}\frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2$ $Cost(h_\theta(x^{(i)}) , y^{(i)}) = \frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2$ Logistic 回归：$$Cost(h_\theta(x^{(i)}) , y^{(i)}) = \begin{cases} -log(h_\theta(x)) &amp; \text{if}\space y = 1\\ -log(1 - h_\theta(x)) &amp; \text{if}\space y = 0 \end{cases}$$Note: $y = 0 \ \text{or}\ 1\ \text{always}$ 结合函数图像比较好理解。 Simplified cost function and gradient descent$Cost(h_\theta(x) , y) = -y log(h_\theta(x)) - (1 - y)log(1 - h_\theta(x))$ $J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}Cost(h_\theta(x^{(i)}), y^{(i)}) = -\frac{1}{m}[\sum\limits_{i = 1}^{m} y^{(i)}log\space h_\theta(x^{(i)}) + (1 - y^{(i)})log(1 - h_\theta(x^{(i)})]$ 拟合参数 $\theta$: $\min\limits_{\theta}J(\theta)$ 针对一个新的 $x$ 预测输出值： Output $h_\theta(x) = \frac{1}{1+e^{-\theta^T x}}$ want $\min\limits_{\theta}J(\theta)$: Repeat {$\theta_j := \theta_j -\alpha\frac{\partial}{\partial\theta_j}J(\theta)$} $\frac{\partial}{\partial\theta_j}J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}(h_\theta(x^{(i)}), y^{(i)})x_j^{(i)}$ Advanced Optimization(高级优化)Optimization algorithm Gradient descent（梯度下降）Conjugate gradient（共轭梯度法）BFGS（变尺度法）L-BFGS（限制变尺度法） 后三种算法优点：不需要手动选择学习率一般情况下比梯度下来收敛得更快缺点：更加复杂 Example:$$\theta = \begin{bmatrix} \theta_0\\ \theta_1\\ \end{bmatrix}$$ $J(\theta) = (\theta_1 - 5)^2 + (\theta_2 - 5)^2$ $\frac{\partial}{\partial\theta_1}J(\theta) = 2(\theta_1 - 5)$ $\frac{\partial}{\partial\theta_2}J(\theta) = 2(\theta_2 - 5)$ 12345678910function [jVal, gradient] = costFunction(theta)truejVal = (theta(1) - 5)^2 + (theta(2) - 5)^2;truegradient = zeros(2, 1);truegradient(1) = 2*(theta(1) - 5);truegradient(2) = 2*(theta(2) - 5);options = optimset(&apos;GradObj&apos;, &apos;on&apos;, &apos;MaxIter&apos;, &apos;100&apos;);initialTeta = zeros(2,1);[optTheta, functionVal, exitFlag] true= fminunc(@costFunction, initialTheta, options); Multiclass Classification: One-vs-allOne-vs-all(one-vs-rest) $h_\theta^{(i)}(x) = P(y = i | x;\theta)\space(x = 1,2,3)$ 给定新的输入 $x$ 值，选择对应类别： $\max\limits_{i} h_\theta^{(i)}(x)$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
        <tag>Machine Learning</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo代码高亮及代码块出现滚动条]]></title>
    <url>%2F2016%2F10%2F01%2FHexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%9D%97%E5%87%BA%E7%8E%B0%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[昨晚不知道因为改了什么配置，导致原先默认的Next主题的代码高亮失效了，接下来就是一番折腾。 代码高亮确认下站点的_config.yml，包含以下配置: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: true 接下来，就不能按照之前代码只用缩进块来表示为代码块了，这样不能高亮啊，真是神奇了 此时应该使用Markdown语法的，用``` code block ```，用六个 ` 把代码包起来```cpp (这里就可以随意发挥了，肯定不仅仅是cpp啊，java/javascript/C/objc/shell…写不下了) 此处应有代码``` 可以了，设置完成，就可以happy般的去 hexo clean;hexo g;hexo s, 本地查看一下代码高亮效果； 代码块滚动条本以为这样就万事大吉了，查看更新的网页，代码是高亮了，却出现了恶心的滚动条，不管代码是几行，都会出现那个滚动条，还是左右两边都有，作为强迫症患者怎么可以忍受，接着Google了一大圈，找到了良药 使用github和hexo搭建博客问题总结 感谢该博主精心研究 对应需要修改的内容node_modules/hexo-util/lib/highlight.js 将第一段代码修改成下面第二段代码，div标签修改为span，并增加换行br 12345678for (var i = 0, len = lines.length; i &lt; len; i++) &#123; line = lines[i]; if (tab) line = replaceTabs(line, tab); numbers += '&lt;div class="line"&gt;' + (firstLine + i) + '&lt;/div&gt;'; content += '&lt;div class="line'; content += (mark.indexOf(firstLine + i) !== -1) ? ' marked' : ''; content += '"&gt;' + line + '&lt;/div&gt;';&#125; 12345678for (var i = 0, len = lines.length; i &lt; len; i++) &#123; line = lines[i]; if (tab) line = replaceTabs(line, tab); numbers += '&lt;span class="line"&gt;' + (firstLine + i) + '&lt;/span&gt;&lt;br&gt;'; content += '&lt;span class="line'; content += (mark.indexOf(firstLine + i) !== -1) ? ' marked' : ''; content += '"&gt;' + line + '&lt;/span&gt;&lt;br&gt;';&#125; 代码高亮又恢复如初，就是得把之前几篇博客的代码中，加上``` ```]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>代码高亮</tag>
        <tag>滚动条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera-Machine Learning 之 Logistic Regression (逻辑回归)-0x01]]></title>
    <url>%2F2016%2F09%2F30%2FCoursera-Machine-Learning-%E4%B9%8B-Logistic-Regression-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-0x01%2F</url>
    <content type="text"><![CDATA[原文首发于个人CSDN博客：http://blog.csdn.net/kalenzh/article/details/43734479 Hypothesis Representation （假设函数表达式） Logistic Regression Model Want $0\leq h_{\theta}(x) \leq 1$ $$\left. \begin{array}{l} h_{\theta}(x) = g(\theta^{T}x) \\ g(z) = \dfrac{1}{1+e^{-z}} \end{array} \right\} \to h_{\theta}(x) = \dfrac{1}{1+e^{-\theta^{T}x}}$$ Sigmoid functionLogistic functionThis two concept are basically synonyms and mean the same things.这两个函数概念基本是同义词，表示了$g(z)$ Sigmoid function wiki pedia Sigmoid 函数 百度百科 Interpretation of Hypothesis Output 对于一个已存在的数据集，我们需要为假设函数寻找一个$\theta$来拟合这个数据集； $h_{\theta}(x) = P(y=1|x;\theta)$在给定的特征值$x$，参数值$\theta$下，$y=1$的概率。 $P(y=0|x;\theta) = 1 - P(y=1|x;\theta)$ Decision Regression（决策边界） Logistic Regression 假设预测：如果 $h_{\theta}(x) \geq 0.5$，则 $y=1$；如果 $h_{\theta}(x) &lt; 0.5$，则 $y=0$； 在$g(z)$函数中如果 $z \geq 0$，则 $0.5\leq g(z)&lt;1$；如果 $z&lt;0$，则 $0&lt; g(z)&lt;0.5$； 所以$\color{blue}{\theta^{T}x \geq 0} \Rightarrow h_{\theta}(x)\geq0.5 \Rightarrow \color{blue}{y = 1}$$\color{navy}{\theta^{T}x &lt; 0} \Rightarrow h_{\theta}(x) &lt; 0.5 \Rightarrow \color{navy}{y = 0}$ Decision Boundary $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2})$ 假设： $\theta_{0} = -3, \theta_{1} = 1, \theta_{2} = 1$$$\theta = \begin{bmatrix} -3\\ 1\\ 1 \end{bmatrix}$$ Predict$&quot;y = 1&quot;$ if $ -3 + x_{1} + x_{2} \geq 0$$&quot;y = 0&quot;$ if $ -3 + x_{1} + x_{2} &lt; 0$ 这里可以看出 $x_{1} + x_{2} = 3 $ 这条线 是上述两个等式取不同值得分界线，这条分界线就被称为决策边界；在这里，决策边界是假设函数的一个属性，由参数决定，与数据集无关。 Non-linear decision Boundaries $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{2}^{2})$ support:$$\theta = \begin{bmatrix} -1\\ 0\\ 0\\ 1\\ 1 \end{bmatrix}$$ Predict$”y = 1”$ if $ -1 + x_{1}^{2} + x_{2}^{2} \geq 0$$”y = 0”$ if $ -1 + x_{1}^{2} + x_{2}^{2} &lt; 0$ 此时，决策边界为 $ x_{1}^{2} + x_{2}^{2} = 1$ 参数 $\theta$ 并不是由训练集所决定的，但是可以由训练集拟合出 $\theta$ 高阶复杂的假设函数： $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{1}^{2} x_{2} + \theta_{5} x_{1}^{2} x_{2}^{2}+ ...)$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
        <tag>Machine Learning</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译] 用GDB学习C语言]]></title>
    <url>%2F2015%2F08%2F03%2F%E7%BF%BB%E8%AF%91-%E7%94%A8GDB%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[原文：https://www.recurse.com/blog/5-learning-c-with-gdb 对于高级语言背景的使用者，就像Ruby, Scheme或者Haskell，学习 C 语言是极具挑战性的。除了要与 C 语言的低级特性，像手动管理内存和指针作斗争外，你还需要在没有交互式编程的环境下，完成整个学习过程。一旦你习惯了在交互式编程环境中的编程之路，你就会对这种写代码-编译-运行的循环过程感到无聊。 最近我想到可以使用GDB当做C的伪交互式编程环境。我一直将使用gdb作为学习C语言的工具，而不仅仅是调试C语言，并且这有很多的乐趣。 我这篇文章的目的，是告诉你，gdb是学习C语言的很好的工具。我将向你介绍一些我喜欢的gdb命令，然后我将演示如何使用gdb来理解，众所周知的C语言的棘手问题：数组和指针的区别。 gdb概述以下面这小段C程序作为开始，minimal.c12345int main()&#123; int i = 1337; return 0;&#125; 注意，程序中并没有其他内容，也没有单独的printf语句，看好了，这就是使用gdb学习C语言的勇敢新世界。 用gcc -g 选项对其进行编译，使得目标文件带有gdb调试信息，然后用gdb调试它。12$ gcc -g minimal.c -o minimal$ gdb minimal 这下你就能看到一个非常明显的gdb提示符，我之前承诺的交互式编程环境，这就是了：12(gdb) print 1 + 2$1 = 3 神奇的地球！ print 是gdb的内置命令，用来打印C语言表达式的赋值结果； 如果你不确定某条gdb命令是干嘛的，就在gdb提示符后面输入 help ‘command’； 接下来是一些比较有趣的例子：12(gbd) print (int) 2147483648$2 = -2147483648 这里我将忽略讨论为什么2147483648 == -2147483648，关键点在于即使是C语言也能在算术上玩出花样，而gdb也能深谙其中之道。 现在我们在main函数上设置一个断点，然后启动程序：12(gdb) break main(gdb) run 程序现在停在第三行，在 i 变量初始化之前，非常有趣，即使 i 没有初始化，我们也可以用print命令查看i的值12(gdb) print i$3 = 32767 在C语言中，一个没有初始化的局部变量的值是未定义的，所以gdb可能会在你的屏幕上输出与我不一样的值； 接下来，可以使用next命令执行当前行：123(gdb) next(gdb) print i$4 = 1337 用x命令检查内存在C语言中，变量存在标签连续的内存块中，一个变量的内存块，由以下两个数字特征来决定： 内存块中第一个字节的数值地址； 用字节衡量的内存块大小，变量块的大小由变量类型决定。 C语言有个独特的特性，就是你可以直接访问变量所在的内存块，‘&amp;’操作符将计算出变量的地址，sizeof 操作符将计算出变量在内存中的大小； 你可以用gdb玩一下这两个概念：1234(gdb) print &amp;i$5 = (int *) 0x7fff5fbff584(gdb) print sizeof(i)$6 = 4 总之，这里的意思是，变量 i 所在内存块起始地址为0x7fff5fbff584，并且占用了4个字节内存。 上面提到的变量在内存中的大小是取决于变量类型的，而且，sizeof操作符确实可以直接对类型进行操作：1234(gdb) print sizeof(int)$7 = 4(gdb) print sizeof(double)$8 = 8 这就意味着，至少在我的机器上，int 变量将占用4字节空间，而double变量将会占用8字节空间。 gdb随身携带了一个强有力的直接用来检查内存的工具：x 命令。 x 命令从一个特定的地址开始检查内存，它附带了格式化命令，用来准确控制你想要检查的字节数，还有就是你想怎么将其打印显示出来；如果还有什么疑问的话，在gdb提示符下运行 help x。 ‘&amp;’ 操作符计算出一个变量的地址，也就是说，我们可以让 x 命令 检查一下 &amp;i，从而就可以看出 i 的值下原始的字节是什么样的：12(gdb) x/4xb &amp;i0x7fff5fbff584: 0x39 0x05 0x00 0x00 上面的标志标明我要检查的是4个字节，并格式化为16进制数，每次一个字节；我选择检查4个字节是因为 i变量在内存中占用的大小就是4个字节，打印的结果，显示出了它在内存中原始的字节挨着字节的表示。 有个需要铭记的微妙的地方就是，在英特尔（Intel）处理器的机器上，原始字节是按照“小端”顺序存储的；与人类文字符号不同，它的低位数是存在内存的前面部分的。 一个验证这个问题的方法就是：给i一个特定的值，并重新检查相应的内存块；123(gdb) set var i = 0x12345678(gdb) x/4xb &amp;i0x7fff5fbff584: 0x78 0x56 0x34 0x12 用ptype命令检查类型ptype命令可能是我最喜欢的命令了，它会告诉我一个C表达式的类型（变量，函数等）；123456(gdb) ptype itype = int(gdb) ptype &amp;itype = int *(gdb) ptype maintype = int (void) 类型本身在C语言中是挺复杂的，但是ptype会给你一个交互式的查看方式。 指针和数组C语言的数组是一个神奇且微妙的概念，我们这一节的计划是写个小程序，并在gdb调试中探索下数组的意义； 编写以下代码，arrays.c:12345int main()&#123; int a[] = &#123;1,2,3&#125;; return 0;&#125; 用-g标志编译，用gdb运行起来，然后next到初始化数组那一行；12345$ gcc -g arrays.c -o arrays$ gdb arrays(gdb) break main(gdb) run(gdb) next 这个时候你就可以打印出a的内容，并检查它的类型：1234(gdb) print a$1 = &#123;1, 2, 3&#125;(gdb) ptype atype = int [3] 现在我们的程序已经在gdb里正常运行了，现在要做的第一件事就是用x命令查看下a在内存里的情况：123(gdb) x/12xb &amp;a0x7fff5fbff56c: 0x01 0x00 0x00 0x00 0x02 0x00 0x00 0x000x7fff5fbff574: 0x03 0x00 0x00 0x00 这就意味着 a 变量所在内存块起始地址为0x7fff5fbff56c。 前四个字节存储a[0]，接下来四个字节存储a[1]，最后四个字节存储a[2]。 你的确还可以通过 sizeof 知道 a 在内存中的大小是12个字节：12(gdb) print sizeof(a)$2 = 12 这个时候，数组看起来就相当像数组了。他们有自己的类数组类型和存储成员的连续内存块。然而，在现实情况中，数组扮演得更像一些指针。举个例子，我们可以对a做指针运算：1234= preserve do :escaped (gdb) print a + 1 $3 = (int *) 0x7fff5fbff570 也就是说，a+1 指向的是个int指针，指向地址为0x7fff5fbff570。 这个时候，你应该本能地想到将这个指针传递给x命令，然后看看发生了什么：1234= preserve do :escaped (gdb) x/4xb a + 1 0x7fff5fbff570: 0x02 0x00 0x00 0x00 这就可以看出0x7fff5fbff570 这个地址比a的第一个字节地址 0x7fff5fbff56c 大4. 由于给定的int的值是要占据4个字节的，这就意味着a+1指向a[1]. 实际上，C语言的数组索引是指针运算的语法糖：a[i]和*(a + i)是相等的。你可以在gdb里试试看：1234567891011121314= preserve do :escaped (gdb) print a[0] $4 = 1 (gdb) print *(a + 0) $5 = 1 (gdb) print a[1] $6 = 2 (gdb) print *(a + 1) $7 = 2 (gdb) print a[2] $8 = 3 (gdb) print *(a + 2) $9 = 3 我们可以看出，在一些情况下，a扮演者数组的角色，而在另外一些情况下，a又像个指向它第一个元素的指针，这到底怎么回事？ 答案就是：在C语言中，当一个变量被命名为数组是，它就退化为指向数组第一个元素的指针。 这个规则有两个例外情况：一个是对数据进行sizeof操作，另一个是对数据进行&amp;操作。 实际上，对a进行&amp;操作时，a并不会退化为指针，这就带来了个有趣的问题：a退化为指针和&amp;a是不是有什么不同？ 从数值上看，他们代表的是同样的地址：123456= preserve do :escaped (gdb) x/4xb a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 (gdb) x/4xb &amp;a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 然而，他们的类型是不同，我们已经看过退化为指针的a是个指向a的第一个元素的指针，所以它的类型必定为int*。至于&amp;a的类型，我们可以直接请教一下gdb：1234= preserve do :escaped (gdb) ptype &amp;a type = int (*)[3] 也就是说，&amp;a是个指向三个整型数数组的指针。这就说得通了：对a进行&amp;操作，a并不会退化，并且a的类型是int[3]。 通过对a的退化值和&amp;a进行指针运算，你可以观察下两者的行为区别：123456= preserve do :escaped (gdb) print a + 1 $10 = (int *) 0x7fff5fbff570 (gdb) print &amp;a + 1 $11 = (int (*)[3]) 0x7fff5fbff578 注意到，a+1 就是给指针加4，而给&amp;a + 1是给指针加12！ 指向a的指针实际上是退化成&amp;a[0]：1234= preserve do :escaped (gdb) print &amp;a[0] $11 = (int *) 0x7fff5fbff56c 结论希望我说服了你，gdb是个学习C语言环境，它简洁而又富有探索意味。你可以打印表达式的值，检查内存的连续字节，用ptype鼓捣一下类型系统。 如果你想知道更多的如何通过gdb学习C语言的内容，以下是我的一些建议： 使用gdb去通过这个挑战 Ksplice pointer challenge.； 了解一下结构体在内存中是怎么存储的，并拿它与数组进行比较； 使用gdb的 disassemble命令学习汇编语言，一个特别有趣的练习是了解西函数是怎么调用堆栈进行工作的； 检查下gdb的 ‘tui’ 模式，它提供一个在常规gdb之上的ncurses图层；在OS X系统中，你可能需要通过源码来安装gdb。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 100. Same Tree]]></title>
    <url>%2F2015%2F06%2F30%2FLeetCode-100-Same-Tree%2F</url>
    <content type="text"><![CDATA[100.Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 给定两个二叉树，写个函数来检查他们是否相等； 考虑两个二叉树的相等于否，需要判断他们结构上是否一致并且对应每个节点上的值是否相等。 12345678910111213141516171819/*** Definition for binary tree* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (p == NULL &amp;&amp; q == NULL) return true; if ((!p &amp;&amp; q) || (p &amp;&amp; !q) || (p-&gt;val != q-&gt;val)) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; tip: 两树都为空，返回true； 两树其中一个为空，另一个不为空，或者值不相等，返回false； 当前节点值相等，则嵌套判断两树的左右树是否相等；]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]算法(字符串移动，单词翻转)]]></title>
    <url>%2F2015%2F06%2F25%2FAlgorithm-%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E5%8A%A8%EF%BC%8C%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目1：定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部，如把字符串abcdef左旋转2位得到字符串cdefab。 请实现字符串左旋转的函数，要求对长度为n的字符串操作的时间复杂度为O(n)，空间复杂度为O(1) 题目2：输入一个英文句子，番句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。句子中标点符号和普通字母一样处理。 例如输入“I am a student.”，则输出“student. a am I”。 解决方法：先将整个句子翻转，再将其中的每个单词翻转 Code (cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; void reverse(char *s, int from, int to) &#123; while(from &lt; to) &#123; char t = s[from]; s[from++] = s[to]; s[to--] = t; &#125; &#125; void WordRotateString(char *s) &#123; reverse(s, 0, strlen(s)-1); int start = 0; int end = 0; while(s[start] !='\0') &#123; if(s[end] == '\0') break; if(s[end] == ' ') &#123; reverse(s, start, end-1); end++; start = end; &#125; else end++; &#125; &#125; void LeftRotateString(char *s, int n,int m) &#123; m %= n; reverse(s, 0, m-1); reverse(s, m, n-1); reverse(s, 0, n-1); &#125; int main(int argc, char **argv) &#123; //反转字符 string s = "abcdefg"; cout &lt;&lt; s &lt;&lt; endl; LeftRotateString((char *)s.c_str(), s.length(), 2); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; endl; //单词反转 s = "I am a student."; cout &lt;&lt; s &lt;&lt; endl; WordRotateString((char *)s.c_str()); cout &lt;&lt; s &lt;&lt; endl; return 0; &#125; Reference程序员编程艺术：第一章、左旋转字符串]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 27.Remove Element]]></title>
    <url>%2F2015%2F06%2F23%2FLeetCode-27-Remove-Element%2F</url>
    <content type="text"><![CDATA[27.Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 给定一个整型数组 A 和一个整型数 v，删除 A 中所有与 v 相等的元素，并返回新的数组长度； 元素的顺序可以更改，这并不影响你返回新的数组长度的大小。 1234567891011121314class Solution &#123;public: int removeElement(int A[], int n, int elem) &#123; int j = 0; for (int i = 0; i &lt; n; i++) &#123; if(A[i] == elem) &#123; continue; &#125; else &#123; A[j++] = A[i]; &#125; &#125; return j; &#125;&#125;; tip: 不能多开辟空间，只能使用原有的数据，那就定义两个位移来分别判断； 一开始出现的错误是更改过的串A[j++]没有赋值，只做了j++； 可以再简洁一点123456789101112class Solution &#123;public: int removeElement(int A[], int n, int elem) &#123; int j = 0; for (int i = 0; i &lt; n; i++) &#123; if(A[i] != elem) &#123; A[j++] = A[i]; &#125; &#125; return j; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 7.Reverse Integer]]></title>
    <url>%2F2015%2F06%2F18%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[7.Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 整数反转，忽略符号部分。 12345678910111213141516171819202122232425class Solution &#123;public: int reverse(int x) &#123; bool isPositive = true; if (x == INT_MIN || x == INT_MAX) return 0; if (x &lt; 0) &#123; isPositive = false; x *= -1; &#125; long long res = 0; while(x) &#123; res = res*10 + x%10; x/=10; &#125; if(res &gt; INT_MAX) return 0; if(!isPositive) &#123; res *= -1; &#125; return res; &#125;&#125;; tip:1.一开始漏掉了最前面一句判断的，溢出之后都要返回0；2.然后是后面反转之后，因为定义的是long long，所以也要判断返回的是否会溢出。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2015%2F06%2F14%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[1. Two SumGiven an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 给定一个整型数组，找到两个数，使得两个数相加的和为指定的目标数； 注意：索引1必须小于索引2 (index1 &lt; index2) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; int vSize = numbers.size(); vector&lt;int&gt; vIndex; map&lt;int,int&gt; mapNum; int index; for (int i = 0; i &lt; vSize; ++i) &#123; index = mapNum[target - numbers[i]]; if(index) &#123; vIndex.push_back(index); vIndex.push_back(i+1); break; &#125; mapNum[numbers[i]] = i+1; &#125; return vIndex; &#125;&#125;; tip: 暴力解决, 两个for循环, 时间复杂度达到了O(n^2), 不符合要求； 用空间换时间，把对应数及索引创建一个map； 从目标数里减去一个数，查找另外一个数是否在map中，over； note:12vIndex.push_back(index);vIndex.push_back(i+1); 这两句话顺序不可互换, 因为结果要求index1 &lt; index2; index 查找出来的数, 其实是在这句代码1mapNum[numbers[i]] = i+1; 已经加入map中的, 索引 i 一直在递增, 所以 index &lt;= i, 要先加入到返回的vector中。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL injection(SQL 注入攻击) 原理浅析]]></title>
    <url>%2F2015%2F06%2F03%2FSQL-injection-SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.database 数据库A database is an organized collection of data. The data is typically organized to model aspects of reality in a way that supports processes requiring information. 数据库，简单来说可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。 数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。 2.SQL语句结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。1986年10月，美国国家标准学会对SQL进行规范后，以此作为关系式数据库管理系统的标准语言（ANSI X3. 135-1986），1987年得到国际标准组织的支持下成为国际标准。不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。 sql 主要用于对数据库进行一些数据的增、删、改、查操作，数据库管理员使用sql语言对数据库进行管理，部分数据的使用者，使用sql查询获取自己需要的数据。 假设我们拥有一个学生信息管理系统，其中有一张表存储学生的基本信息， 表名 STUDENT_INFO 字段 stuid,name,sex,hometown（对应：学号，姓名，性别，籍贯） STUDENT_INFO stuid name sex hometown 1 Tom M LA 2 Andy F NY 3 Sam M Seattle 12345SELECT * FROM STUDENT_INFO ; -- 查询表中所有记录SELECT name FROM STUDENT_INFO; -- 查询表中所有姓名记录SELECT hometown FROM STUDENT_INFO where name='Tom'; -- 查询出Tom的家乡 3. SQL injectionsql 注入攻击是黑客常用的数据库攻击手段，通过对sql 查询语句的重组与技巧性“填空游戏”，来获取非正常途径下数据库返回的信息。 通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 假如现在需要查询Tom的家乡信息，标准语句1SELECT hometown FROM STUDENT_INFO where name='Tom'; -- 查询出Tom的家乡 现在再拼接出另外一条语句，获取所有人的家乡信息1SELECT hometown FROM STUDENT_INFO where name='Tom' or '1'='1'; 就这样，原本只能获取到Tom的家乡，现在变成能够获取到所有人的家乡信息了，如果这个信息是个人电话号码、身份证号等其他敏感信息，后果不堪设想； where 语句后是一个逻辑判断 原来只有当名字为Tom时，才会返回对应查询的内容，现在拼接了一个‘1’=‘1’，这个等式是恒为真的，所以where后面的语句也就始终为TRUE; 如果这条查询语句是嵌入到Web页面用来查询某网站的语句，本来返回的是个人信息，这么一玩，就可以拿到当前网站数据库中所有其他用户的信息了 现在剥离sql语句，如果表单中只让我们填写要查询的对象“Tom”，要怎么拼接语句 你在表单中填写 Tom ，系统会自动将 Tom 用两个单引号 ‘’ 括起来 ‘Tom’ 再接入到sql语句中去， 这个时候，填空游戏来了， 在表单中填的就不能是where后面的所有字符了， 就变成 Tom‘ or ‘1’=’1 去掉了前后的两个单引号； 4.ReferenceDatabase wikipedia数据库 维基百科SQL wikipediaSQL 维基百科SQL 百度百科SQL注入攻击 百度百科SQL 注入攻击 维基百科SQL injection wikipedia]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>injection</tag>
        <tag>注入攻击</tag>
      </tags>
  </entry>
</search>
