<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git clone 加速]]></title>
    <url>%2F2019%2F05%2F19%2Fgit-clone-%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[起因为了修改自己博客的文件夹命名，就需要将github上的仓库下载到本地，使用git clone时，速度慢到无法接受，就Google了一番git clone加速的办法，记录下来，以便后续查阅。 github速度慢是因为DNS被污染了，原因你懂的，对于解决github的问题，使用代理可能是最好的办法了 使用代理使用这个方法的前提，是你有一个梯子，这个梯子能够让你正常访问Google，梯子怎么搭，这里就不赘述了，我们这里假设你已经有梯子可用，可以设置git通过代理进行访问； 起初我使用了v2ray的全局模式，执行git clone后，发现速度并没有任何变化，Google后发现，git命令并不会直接走全局代理，需要通过git config配置，看完所有命令再操作； 12345678# 千万别急，刚开始而已# socks5协议，1080端口修改成自己的本地代理端口git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080# http协议，1081端口修改成自己的本地代理端口git config --global http.proxy http://127.0.0.1:1081git config --global https.proxy https://127.0.0.1:1081 以上的配置会导致所有git命令都走代理，但是如果你混合使用了国内的git仓库，甚至是局域网内部的git仓库，这就会把原来速度快的改成更慢的了； 下面是仅仅针对github进行配置，让github走本地代理，其他的保持不变； 1234567# socks5协议，1080端口修改成自己的本地代理端口git config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080# http协议，1081端口修改成自己的本地代理端口git config --global http.https://github.com.proxy https://127.0.0.1:1081git config --global https.https://github.com.proxy https://127.0.0.1:1081 其他几个相关命令： 12345# 查看所有配置git config -l# reset 代理设置git config --global --unset http.proxygit config --global --unset https.proxy 看下使用了本地代理前后，速度的差距： Reference 给 github clone 加速 github代码clone加速 第2点的这个方法，没试过，不知道可不可行，感兴趣的朋友可以试试看。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]961. N-Repeated Element in Size 2N Array]]></title>
    <url>%2F2019%2F05%2F15%2FLeetCode-961-N-Repeated-Element-in-Size-2N-Array%2F</url>
    <content type="text"><![CDATA[961. N-Repeated Element in Size 2N ArrayEasy In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: 12Input: [1,2,3,3]Output: 3 Example 2: 12Input: [2,1,2,5,3,2]Output: 2 Example 3: 12Input: [5,1,5,2,5,3,5,4]Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 方法一12345678910111213141516171819class Solution &#123;public: int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123; int n = A.size()/2; map&lt;int, int&gt; item_map; int target; for (int item : A) &#123; if (item_map.count(item)) &#123; if (++item_map[item] == n) &#123; target = item; break; &#125; &#125; else &#123; item_map.insert(make_pair(item, 1)); &#125; &#125; return target; &#125;&#125;; resultRuntime: 88 ms, faster than 8.10% of C++ online submissions for N-Repeated Element in Size 2N Array. Memory Usage: 17.4 MB, less than 6.23% of C++ online submissions for N-Repeated Element in Size 2N Array. 方法二审题啊，审题，审题不详细，代码写再多也是枉然，题目中明确说明，只有一个数字是重复的，其他都是唯一的，这个时候用set最好解决了； 123456789101112131415class Solution &#123;public: int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123; set&lt;int&gt; item_set; int target; for (int item : A) &#123; if (item_set.count(item)) &#123; return item; &#125; else &#123; item_set.insert(item); &#125; &#125; return -1; &#125;&#125;; resultRuntime: 40 ms, faster than 88.98% of C++ online submissions for N-Repeated Element in Size 2N Array. Memory Usage: 10.8 MB, less than 68.86% of C++ online submissions for N-Repeated Element in Size 2N Array. 效果显著，但是不是特别好。 逛一下讨论区，看看网友们的奇技淫巧： https://leetcode.com/problems/n-repeated-element-in-size-2n-array/discuss/208563/JavaC%2B%2BPython-O(1)-Solution 这个作者的方法二和方法三，实在是令人惊叹。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-8]]></title>
    <url>%2F2019%2F05%2F12%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-8%2F</url>
    <content type="text"><![CDATA[ARTS week-8Algorithm[LeetCode]657. Robot Return to Origin ReviewGoogle Takes a Bite Out of Apple 苹果作为软硬件一体的公司，过去对于隐私的控制始终都处在业界领先；不过这一次的Google IO大会之后，这个优势可能会有所减弱； 控制隐私和安全成了此次Google IO大会的一大主题，也成为Google开发许多产品的基石，包括很多产品的隐身模式，还有人脸识别的本地化，最重要的一个产品，应该是人工智能的联合学习，不再需要一堆的数据上传到服务器进行集中训练，而是在终端就可以进行个人数据的个性化学习； 随着全球公众以及政府监管对于隐私安全的逐渐重视，Google对于隐私安全的重视更像是无奈之举，否则可能面临难以估量的后果。 TipJupyter notebook删除cell，Esc—&gt;dd。 Jupyter notebook快捷键 ShareJupyter notebook配置]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook配置]]></title>
    <url>%2F2019%2F05%2F12%2FJupyter-Notebook%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[起因每次更换电脑或者要新建一个Jupyter Notebook环境，都要查找好几个网站，去配置好开发环境，记录一下所有配置，以后就不用频繁使用搜索引擎，却只为了寻找几句配置。 简介Jupyter Notebook是个开源的Web应用，可以创建包含代码、公式、可视化及叙事文本的共享文档； 支持超过40种编程语言 可共享的notebook 交互式的输出 集成大数据工具 配置1. 生成配置文件1jupyter notebook --generate-config 2. 设置密码1jupyter notebook password 3. 修改配置文件12345vim ~/.jupyter/jupyter_notebook_config.py修改以下三个节点的配置，并把开头的 # 注释去掉c.NotebookApp.ip = '*' # 开启所有的IP访问，即可使用远程访问c.NotebookApp.open_browser = False # 关闭启动后的自动开启浏览器c.NotebookApp.port = 8888 # 设置端口8888，也可用其他的，比如1080，8080等等 4. 启动notebook1jupyter notebook 5. 远程访问在浏览器输入http://hostip:8888，hostip可以是本地地址，局域网地址，也可以是远程服务器地址(比如阿里云或者AWS或者其他云服务器厂商的VPS外网地址)。 6. 主题12345678pip install jupyterthemes# list available themes# onedork | grade3 | oceans16 | chesterish | monokai | solarizedl | solarizeddjt -l# select theme...jt -t chesterish 详细步骤还可以查看该工程的github主页：https://github.com/dunovank/jupyter-themes Reference https://jupyter.readthedocs.io/en/latest/projects/config.html https://github.com/dunovank/jupyter-themes]]></content>
      <categories>
        <category>Jupyter</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]657. Robot Return to Origin]]></title>
    <url>%2F2019%2F05%2F11%2FLeetCode-657-Robot-Return-to-Origin%2F</url>
    <content type="text"><![CDATA[657. Robot Return to OriginThere is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is “facing” is irrelevant. “R” will always make the robot move to the right once, “L” will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. Example 1: 123Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: 123Input: &quot;LL&quot;Output: falseExplanation: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves. 大概解释一下题目：机器人从原来（0,0）开始走，用键盘上下左右键，判断最后机器人是否回到原点。 方案一思路：判断是否回到原点，就是左右走动的格数要相等，上下走动的格数也要相等，即count(L) == count(R)而且count(U) == count(D)，循环遍历，代码如下： 1234567891011121314151617class Solution &#123;public: bool judgeCircle(string moves) &#123; map&lt;char, int&gt; move_map; for(char item : moves) &#123; if(move_map.count(item)&gt;0) &#123; move_map[item] = move_map[item]+1; &#125; else &#123; move_map.insert(make_pair(item, 1)); &#125; &#125; if ((move_map['U'] == move_map['D']) &amp;&amp; (move_map['R'] == move_map['L'])) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 36 ms, faster than 7.05% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.3 MB, less than 98.06% of C++ online submissions for Robot Return to Origin. 方案二用两个堆来匹配，U遇到堆顶是D，则pop，否则push，其他类似： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool judgeCircle(string moves) &#123; stack&lt;char&gt; updown_stack; stack&lt;char&gt; lr_stack; for(char item : moves) &#123; if(item=='U') &#123; if (!updown_stack.empty() &amp;&amp; updown_stack.top()=='D') &#123; updown_stack.pop(); &#125; else &#123; updown_stack.push(item); &#125; &#125; else if(item=='D') &#123; if (!updown_stack.empty() &amp;&amp; updown_stack.top()=='U') &#123; updown_stack.pop(); &#125; else &#123; updown_stack.push(item); &#125; &#125; else if(item=='R') &#123; if (!lr_stack.empty() &amp;&amp; lr_stack.top()=='L') &#123; lr_stack.pop(); &#125; else &#123; lr_stack.push(item); &#125; &#125; else if(item=='L') &#123; if (!lr_stack.empty() &amp;&amp; lr_stack.top()=='R') &#123; lr_stack.pop(); &#125; else &#123; lr_stack.push(item); &#125; &#125; &#125; if (updown_stack.empty() &amp;&amp; lr_stack.empty()) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 20 ms, faster than 64.52% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.6 MB, less than 28.68% of C++ online submissions for Robot Return to Origin. 方案三被固定思维所限，其实只要计算左右和上下的次数，用int值来判断就可以，下面这个方案就很好： 12345678910111213141516171819202122class Solution &#123;public: bool judgeCircle(string moves) &#123; int updown=0; int lr=0; for(char item : moves) &#123; if(item=='U') &#123; updown++; &#125; else if(item=='D') &#123; updown--; &#125; else if(item=='L') &#123; lr++; &#125; else if(item=='R') &#123; lr--; &#125; &#125; if (updown==0 &amp;&amp; lr==0) &#123; return true; &#125; return false; &#125;&#125;; resultRuntime: 16 ms, faster than 96.59% of C++ online submissions for Robot Return to Origin. Memory Usage: 10.3 MB, less than 97.29% of C++ online submissions for Robot Return to Origin.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-7]]></title>
    <url>%2F2019%2F05%2F05%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-7%2F</url>
    <content type="text"><![CDATA[ARTS week-7Algorithm[LeetCode]832. Flipping an Image ReviewDrones Transporting Organs For Transplant Is Now A Reality 使用无人机运输需要移植的器官已成为现实 未来将拯救更多生命，无人机作为运输工具，而不再仅仅是娱乐或者是亚马逊的“快递员”哈 从成本上看，肯定是比直升机要低很多，但是作为正式使用的工具，肯定还有很长的路要走，毕竟整个运输过程，器官的安全完整送达，是重中之重；不过已有的成功案例，也让我们对这个方向有所期盼，为这个社会带来更多积极影响。 Tipwindows 10 ubuntu 子系统 中文乱码问题，执行以下命令后，重新开启终端即可； 1234apt-get updateapt-get install language-pack-zh-hansupdate-locale LANG=zh_CN.UTF-8 # 可以选择下面这句update-locale LANG=en_US.UTF-8 # 其实为了支持中文的显示，只需要支持utf8的显示即可 Share本周分享一篇2016年底的老文章，但是现在看来，依然具有参考意义。 谷歌求职记：我花了八个月准备谷歌面试 英文原文：Why I studied full-time for 8 months for a Google interview 作者针对Google面试所列的github仓库：coding-interview-university，里面也有对应的中文版。]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]832. Flipping an Image]]></title>
    <url>%2F2019%2F05%2F02%2FLeetCode-832-Flipping-an-Image%2F</url>
    <content type="text"><![CDATA[832. Flipping an ImageGiven a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: 1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: 1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 题目大概解释一下：二维数组，水平翻转，再取反。 方案一思路：遍历每一行，对每行的元素先做翻转，再取反，时间复杂度 n^2 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; reversAndInvert(vector&lt;int&gt; &amp;in) &#123; int len = in.size(); vector&lt;int&gt; out(len); for(int i = 0; i &lt; len; ++i) &#123; out[i] = !in.at(len-1-i); &#125; return out; &#125; vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int len = A.size(); vector&lt;vector&lt;int&gt;&gt; result(len); for(int i = 0; i &lt; len; ++i) &#123; result[i] = reversAndInvert(A.at(i)); &#125; return result; &#125;&#125;; resultRuntime: 20 ms, faster than 21.52% of C++ online submissions for Flipping an Image. Memory Usage: 9.3 MB, less than 100.00% of C++ online submissions for Flipping an Image. 预料到时间会比较高，毕竟时间复杂度是 n^2（后面解释，慢竟然不是因为这个原因）。 方案二从讨论区里面找到一个方案，再稍微修改下，使用了reverse函数，并通过引用修改原有元素，而且使用了异或操作。 123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; for (auto &amp; row : A) &#123; reverse(row.begin(), row.end()); for (int &amp; i: row) &#123; i ^= 1; &#125; &#125; return A; &#125;&#125;; resultRuntime: 12 ms, faster than 100.00% of C++ online submissions for Flipping an Image. Memory Usage: 9.3 MB, less than 99.61% of C++ online submissions for Flipping an Image. 其实套路基本差不多，但是有个很关键的操作 i ^= 1;，这个异或操作比方案一的 ! 操作，效率高很多。 把方案一的 ! 操作，换成异或后，也得到了类似的效果，不过新开辟的vector就多了空间复杂度。 Runtime: 12 ms, faster than 100.00% of C++ online submissions for Flipping an Image. Memory Usage: 9.5 MB, less than 99.22% of C++ online submissions for Flipping an Image.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-6]]></title>
    <url>%2F2019%2F04%2F28%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-6%2F</url>
    <content type="text"><![CDATA[ARTS week-6Algorithm[LeetCode]977. Squares of a Sorted Array ReviewAs a Leader, Time Is Your Most Valuable Resource 作为领导者，时间是你最有价值的资源。 要确保你做的所有事都是在帮助你完成最重要的那个目标。 就像凯勒･帕帕森的书《最重要的事，只有一件》。 还有一个规则，就是断舍离，留下那个丢弃后造成痛苦最大的东西。 Tiptuple，可以存放不同类型元素的容器，这周在一个功能开发中使用到了； 手册地址：tuple SharePyTorch 逻辑回归]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 逻辑回归]]></title>
    <url>%2F2019%2F04%2F28%2FPyTorch-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[逻辑回归回归模型，作为机器学习的基本模型，上一次练习了线性回归，这次就说说Logistic Regression。 PyTorch代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import torchimport numpy as npimport torch.nn.functional as Ffrom torchvision import datasets, transformsimport matplotlib.pyplot as pltin_dim = 28*28out_class = 10batch_size = 64# 迭代次数 100epochs_num = 100class LogisticRegression(torch.nn.Module): def __init__(self): super(LogisticRegression, self).__init__() self.logistic = torch.nn.Linear(in_dim, out_class) def forward(self, x): return self.logistic(x) model = LogisticRegression()# 交叉熵损失loss_function = torch.nn.CrossEntropyLoss()# 随机梯度下降，学习率 1e-3#optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)# 另外一个优化方法 Adamoptimizer = torch.optim.Adam(model.parameters(), lr=1e-3)def train(model, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data = data.view(data.size(0), -1) output = model(data) loss = loss_function(output, target) optimizer.zero_grad() loss.backward() optimizer.step() if batch_idx % 100 == 0: print('Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item()))def test(model, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data = data.view(data.size(0), -1) output = model(data) test_loss += loss_function(output, target).item() # sum up batch loss pred = output.argmax(dim=1, keepdim=True) # get the index of the max log-probability correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset)))train_loader = torch.utils.data.DataLoader( datasets.MNIST('./data', train=True, download=True, transform=transforms.ToTensor()), batch_size=batch_size, shuffle=True)test_loader = torch.utils.data.DataLoader( datasets.MNIST('./data', train=False, transform=transforms.ToTensor()), batch_size=batch_size, shuffle=True)for epoch in range(epochs_num): train(model, train_loader, optimizer, epoch) test(model, test_loader) 可以调整学习率、迭代次数、优化方法，看看不同的调整，会有什么不同的结果 使用SDG，学习率为1e-3时，收敛速度有些慢，迭代了73次才达到91\%，最终准确率稳定在$91\%$； 使用Adam，学习率一样为1e-3，收敛速度很快，一轮就能达到90\%，接下来就是一直在90\% 和 91\%之间徘徊； 简单的回归，对于多分类还是心有余而力不足，后面会再用二分类练习逻辑回归，也会用神经网络来训练下MNIST数据集。 SDG训练了100次后的结果，如下图： 代码也可以查看我的GitHub仓库LogisticRegression，如有错误，欢迎指出。]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>逻辑回归</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]977. Squares of a Sorted Array]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode-977-Squares-of-a-Sorted-Array%2F</url>
    <content type="text"><![CDATA[977. Squares of a Sorted ArrayGiven an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Example 1: 12Input: [-4,-1,0,3,10]Output: [0,1,9,16,100] Example 2: 12Input: [-7,-3,2,3,11]Output: [4,9,9,49,121] Note: 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A is sorted in non-decreasing order. 大概解释下题目：有序的有符号数组元素平方后排序。 方案一思路：迭代循环每个元素进行平方，然后再用sort排序 1234567891011class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; unsigned int size = A.size(); for (unsigned int i = 0; i &lt; size; ++i) &#123; A[i] = A[i]*A[i]; &#125; sort(A.begin(), A.end()); return A; &#125;&#125;; resultRuntime: 124 ms, faster than 45.70% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.4 MB, less than 100.00% of C++ online submissions for Squares of a Sorted Array. 内存占用效果不错，但是执行效率就差了，for循环的原因？ 方案二新建一个数组替换原来的A 123456789101112class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; unsigned int len = A.size(); vector&lt;int&gt; out(len); for (unsigned int i = 0; i &lt; len; ++i) &#123; out[i] = A[i]*A[i]; &#125; sort(out.begin(), out.end()); return move(out); &#125;&#125;; resultRuntime: 120 ms, faster than 58.11% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.5 MB, less than 99.64% of C++ online submissions for Squares of a Sorted Array. 效果并没有好多少。 方案三读题不够仔细，原始数组就是有序的，只不过是包含了负数而已，这个排序就可以用来比较了，以下这个方案是讨论区的答案，有点巧妙。 12345678910class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; out(A.size()); for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn &lt;= pp; --pos) &#123; out[pos] = pow(abs(A[pn]) &lt; abs(A[pp]) ? A[pp--] : A[pn++], 2); &#125; return out; &#125;&#125;; resultRuntime: 100 ms, faster than 98.97% of C++ online submissions for Squares of a Sorted Array. Memory Usage: 13.3 MB, less than 100.00% of C++ online submissions for Squares of a Sorted Array. 执行效率和内存占用表现都相当好； tip后续类似循环的题目，最高的效率就是要在同一个循环里面，把多件事同时做了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-5]]></title>
    <url>%2F2019%2F04%2F21%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-5%2F</url>
    <content type="text"><![CDATA[ARTS week-5Algorithm[Leetcode]905. Sort Array By Parity Review23 great Pandas codes for Data Scientists 这周的review只算是勉强完成，后续会用扇贝对应的文章进行review Tipclose(0) 的坑 If fclose(0) is called, does this close stdin? 多线程的使用中，如果没有判断socket的文件描述符是否大于0，而直接close(0)，会导致不知名的崩溃，stackoverflow也有了对应的说明。 SharePyTorch 线性回归]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 线性回归]]></title>
    <url>%2F2019%2F04%2F21%2FPyTorch-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[线性回归线性回归是机器学习中最基本的模型，也是必须掌握的模型，其中涉及到最小二乘法，均方误差等，目的就是求得一条直线拟合一些点，首先生成如下图片的点，下面会用pytorch代码实现直线的拟合。 PyTorch代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import torchimport numpy as npimport torch.nn.functional as Fimport matplotlib.pyplot as plt# y = 5.2x+3 一元线性函数，斜率 5.2，截距3true_w = 5.2true_b = 3x = torch.unsqueeze(torch.linspace(-2, 2, 100), dim=1)y = true_w*x + true_b# 为y值增加高斯噪音，弄得像随机的，等下拟合出一条直线来回归这些点y = y + torch.randn(x.size()) # 打印散点图plt.scatter(x.data.numpy(), y.data.numpy())plt.show()# plt更新plt.ion()plt.show()# 定义一个线性回归的类，继承于Moduleclass LinearRegression(torch.nn.Module): def __init__(self): super(LinearRegression, self).__init__() self.linear = torch.nn.Linear(1, 1) # 线性模型，一个输入，一个输出 def forward(self, x): return self.linear(x) model = LinearRegression()# 均方误差损失loss_function = torch.nn.MSELoss()# 随机梯度下降，学习率 1e-3optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)# 另外一个优化方法 Adam#optimizer = torch.optim.Adam(model.parameters(), lr=2e-2)# 迭代次数 2000epochs_num = 2000for epoch in range(epochs_num): # forward out = model(x) loss = loss_function(out, y) # backward optimizer.zero_grad() # 梯度还原为零 loss.backward() # 反向传播 optimizer.step() # 更新参数 if (epoch+1) % 20 == 0: # print('Epoch[&#123;&#125;/&#123;&#125;], loss: &#123;:.6f&#125;'.format(epoch+1,epochs_num,loss.data.item())) plt.cla() plt.scatter(x.data.numpy(), y.data.numpy()) plt.plot(x.data.numpy(), out.data.numpy(), 'r-', lw=5) plt.text(-2, 12, 'Loss=%.4f' % loss.data.numpy(), fontdict=&#123;'size':15, 'color':'red'&#125;) plt.pause(0.1)plt.ioff()plt.show() 可以调整学习率、迭代次数、优化方法，看看不同的调整，会有什么不同的结果 学习率太小，可能导致迭代速度过慢，迭代次数结束后，损失还很大 学习率太大，可能导致无法收敛，并出现振荡，迭代结束后，损失依然大 Adam使用的学习率与SDG使用的学习率并不一定会一样 最后拟合出来的图像如下图： 代码也可以查看我的GitHub仓库LinearRegression，如有错误，欢迎指出。]]></content>
      <categories>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>PyTorch</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]905. Sort Array By Parity]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode-905-Sort-Array-By-Parity%2F</url>
    <content type="text"><![CDATA[905. Sort Array By ParityGiven an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Example 1: 123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 题目解析：将奇偶数排序，偶数在前，奇数在后，偶/奇数内部无需关心排序； 方案一思路：一个数组，遍历数组，新建一个vector用于返回，偶数在前面插入，奇数在后面插入； 1234567891011121314class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; out; for (const int item: A) &#123; if (item % 2 == 0) &#123; out.emplace(out.begin(), item); &#125; else &#123; out.emplace_back(item); &#125; &#125; return out; &#125;&#125;; resultRuntime: 64 ms, faster than 10.14% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.9 MB, less than 98.71% of C++ online submissions for Sort Array By Parity. 执行时间太多了！怎么这么慢 方案二 返回的数组大小也是固定的，初始化固定长度的vector； 循环迭代的同时赋值，对应index++或者index—； 其中 &amp; 运算和 % 运算，从效率上来说并没有差别，换了之后也差不多； 123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; int len = A.size(); vector&lt;int&gt; out(len); for (int i = 0, begin_out = 0, end_out = len - 1; i &lt; len; i++) &#123; if (A[i] &amp; 1) &#123; out[end_out--] = A[i]; &#125; else &#123; out[begin_out++] = A[i]; &#125; &#125; return move(out); &#125;&#125;; resultRuntime: 28 ms, faster than 98.35% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.7 MB, less than 99.36% of C++ online submissions for Sort Array By Parity. 方案三高手在民间，网友出绝招，讨论区的解决方案，效率上差不多，就是相当简洁。 12345678class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; auto is_even = [] (auto e) &#123; return e % 2 == 0; &#125;; partition (A.begin (), A.end (), is_even); return A; &#125;&#125;; resultRuntime: 28 ms, faster than 98.35% of C++ online submissions for Sort Array By Parity. Memory Usage: 9.6 MB, less than 99.36% of C++ online submissions for Sort Array By Parity.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-4]]></title>
    <url>%2F2019%2F04%2F14%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-4%2F</url>
    <content type="text"><![CDATA[ARTS week-4Algorithm [Leetcode]804. Unique Morse Code Words [Leetcode]929. Unique Email Addresses [Leetcode]595. Big Countries ReviewData scientist: The sexiest job of the 22nd century 决策者需要知道数据科学家能做什么，而不是数据科学家什么都能做，首先应该避免以下问题： 毫无技术领导力； 没数据就别谈效果，巧妇难为无米之炊； 垃圾透顶的工具（开发工具、开发语言、运行平台等）； 如果什么事都由你来做，那也就不是纯粹的数据科学家了； 关于工具和平台，应该是个完善的体系，而不是玩具，也不是说买买买就一定好用，适合更重要； 从设计师的视角看问题； 千万不要在一家没有数据的公司成为数据科学家； 为什么作者说数据科学家是22世纪最性感的工作，而不是现在？可能是这个世纪对数据科学家太不“友好”了。 Tip超级剪切板Ditto，windows下的剪切板神奇，历史拷贝都会保存，还能包含图片，文档等，极力推荐。 ShareC++ remove erase 用法浅析]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ remove erase 用法浅析]]></title>
    <url>%2F2019%2F04%2F12%2FC-remove-erase-%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[C++ remove erase 用法浅析remove 用法浅析写这篇浅析完全是意料之外的，只怪才疏学浅。 刷[Leetcode]929. Unique Email Addresses的时候不能用boost库，一脸懵逼，为了去除整个字符串中的“.”，boost库中就是一句话boost::erase_all(str, ‘.’)，但是stl库中没有现成的接口可以使用，求助Google，发现了erase和remove结合使用可以达到目的； 1local.erase(remove(local.begin(), local.end(), '.'), local.end()); // 删除local字符串中所有的'.' 但是这样的用法没玩过，不是特别好理解，写个demo验证下，先看代码： 123456789101112131415161718192021222324#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[])&#123; string str = "helloworld"; cout &lt;&lt; "before remove: " &lt;&lt; str &lt;&lt; endl; string::iterator ret_end = remove(str.begin(), str.end(), 'o'); // remove字符串中所有的‘o’，此时并没有真正删除 cout &lt;&lt; "after remove: " &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; "ret_end: "; for (string::iterator i = str.begin(); i &lt; ret_end; i++) &#123; cout &lt;&lt; *i; // 这里打印的结果是从str的开头，到截止remove返回的应该结束的位置； &#125; cout &lt;&lt; endl; str = "helloworld"; cout &lt;&lt; "before erase: " &lt;&lt; str &lt;&lt; endl; str.erase(remove(str.begin(), str.end(), 'o'), str.end()); cout &lt;&lt; "after erase: " &lt;&lt; str &lt;&lt; endl; return 0;&#125; 先看下输出结果： 12345before remove: helloworldafter remove: hellwrldldret_end: hellwrldbefore erase: helloworldafter erase: hellwrld 具体看下remove的接口，cpluscplus手册上的链接std::remove 12template &lt;class ForwardIterator, class T&gt; ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val); 输入三个参数：迭代器起始，迭代器结束，要移除的值； 返回：迭代器，指向未移去的最后一个元素的下一个位置； 手册里面有一句解释： The range between first and this iterator includes all the elements in the sequence that do not compare equal to val. [first return)之间（不包含return指定的元素，到前一个截止），包含的是所有和val不等的元素，如上面demo中ret_end所示： ret_end: hellwrld // first到ret_end包含所有不等于 ‘o’ 的序列, ret_end则指向的是‘ld’之后的那个‘l’ remove 实现其实remove的实现，手册里面也有描述，就是需要理解一下 12345678910111213template &lt;class ForwardIterator, class T&gt; ForwardIterator remove (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator result = first; while (first!=last) &#123; if (!(*first == val)) &#123; // first不等于val时，result对应的值才会更新，并指向下一个元素 *result = move(*first); ++result; &#125; ++first; &#125; return result;&#125; 就到这。。顺便吐槽 一下csdn上面的一些帖子，看了好多篇，也没有说到点子上，还有解释错的，更是有抄错的。。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]595. Big Countries]]></title>
    <url>%2F2019%2F04%2F11%2FLeetCode-595-Big-Countries%2F</url>
    <content type="text"><![CDATA[595. Big Countries今天这道题，是个sql语句的题目，选出符合条件的数据； There is a table World 123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million. Write a SQL solution to output big countries’ name, population and area. For example, according to the above table, we should output: 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ 比较简单，select where就可以解决了； 1select name, population, area from World where area&gt;3000000 or population&gt;25000000; resultRuntime: 196 ms, faster than 82.98% of MySQL online submissions for Big Countries. 结果有点惊讶，这么简单的还会有更好的解决办法？讨论区看了一眼，发现这么一个语句： 1SELECT name, population, area FROM World WHERE area &gt; 3000000 UNION SELECT name, population, area FROM World WHERE population &gt; 25000000; 奇迹出现了？？ 并没有。。。执行完效率并没有好多少，半斤八两。 这个时候就Google一番，or 和 union差在哪里，以下几篇文章有点参考意义。 mysql 实战 or、in与union all 的查询效率 SQL Performance UNION vs OR Whether to use UNION or OR in SQL Server Queries 总的来说，性能差异并不是绝对的，都需要针对实际数据进行实际的测试与验证，其中有一点是关键，对于非索引字段，or是肯定胜过union了。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]929. Unique Email Addresses]]></title>
    <url>%2F2019%2F04%2F09%2FLeetCode-929-Unique-Email-Addresses%2F</url>
    <content type="text"><![CDATA[929. Unique Email AddressesEvery email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain &#39;.&#39;s or &#39;+&#39;s. If you add periods (&#39;.&#39;) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (&#39;+&#39;) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one &#39;@&#39; character. All local and domain names are non-empty. Local names do not start with a &#39;+&#39; character. 大概解释一下题目： 邮箱地址中，本地名称部分可能包含“.”和“+”，其中“.”会直接被忽略掉，而第一个’+’之后，到‘@’之前，则会被截断； 输入：一个邮箱地址的数组； 输出：处理后的邮箱地址，不重复的有多少个； 方案一 local name 和domain name 分开处理，否则domain name的‘.’可能会被错误去除； local name中可能包含多个“+”和多个“.”，“+”比较好处理，后面的直接截断；但是多个“.”就必须循环处理了； 123456789101112131415161718192021class Solution &#123;public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; set&lt;string&gt; email_set; for (string &amp;email : emails) &#123; int atindex = email.find('@'); string local = email.substr(0, atindex); string domain = email.substr(atindex); int plusindex = local.find('+'); if (plusindex != string::npos) &#123; local.erase(plusindex, atindex-plusindex); &#125; if(local.find('.') != string::npos) &#123; local.erase(remove(local.begin(), local.end(), '.'), local.end()); &#125; email_set.insert(local+domain); &#125; return email_set.size(); &#125;&#125;; resultRuntime: 36 ms, faster than 87.14% of C++ online submissions for Unique Email Addresses.Memory Usage: 12.9 MB, less than 87.81% of C++ online submissions for Unique Email Addresses. 方案二：方案一效果不是特别好，local部分其实循环处理了两次，可以把整个字符串从头到尾每个字符判断一遍； 123456789101112131415161718192021222324252627class Solution &#123;public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) &#123; unordered_set&lt;string&gt; emails_set; for (const string&amp; email : emails) &#123; string out; bool at = false; bool plus = false; for (char c : email) &#123; if (c == '.') &#123; if (!at) continue; &#125; else if (c == '@') &#123; at = true; &#125; else if (c == '+') &#123; if (!at) &#123; plus = true; continue; &#125; &#125; if (!at &amp;&amp; plus) continue; out += c; &#125; emails_set.insert(std::move(out)); &#125; return emails_set.size(); &#125;&#125;; resultRuntime: 32 ms, faster than 97.73% of C++ online submissions for Unique Email Addresses.Memory Usage: 11.9 MB, less than 99.28% of C++ online submissions for Unique Email Addresses. 为了降低时间复杂度，降低空间复杂度，尝试各种方法，这一题提交了20次。。。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]804. Unique Morse Code Words]]></title>
    <url>%2F2019%2F04%2F08%2FLeetCode-804-Unique-Morse-Code-Words%2F</url>
    <content type="text"><![CDATA[804. Unique Morse Code WordsInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &quot;a&quot; maps to &quot;.-&quot;, &quot;b&quot; maps to &quot;-...&quot;, &quot;c&quot; maps to &quot;-.-.&quot;, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..—…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 大概解释一下题目：摩斯码，26个小写字母各对应一串密码串，不同的英文单词可能出现同样的摩斯码； 输入：一个数组，数组中包含多个单词； 输出：单词转换成摩斯码后，总的摩斯编码类别有几种； 解题思路： 要得到不同的摩斯码，就是不能有重复的，就可以用集合(set)来存储转换后的摩斯码； 26个小写字母对应的摩斯码是固定的，就用数组直接初始化； 字母a对应的ASCII码为97，数组第一个元素的索引index为0，直接减去97即可得到对应的摩斯码编码； 循环遍历vector中的word，循环遍历word中的每一个字母； 代码如下： 123456789101112131415161718class Solution &#123;public: int uniqueMorseRepresentations(vector&lt;string&gt;&amp; words) &#123; string morse[26] = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; set&lt;string&gt; morse_set; string str_morse; for (string &amp;word : words) &#123; unsigned len = word.length(); for(unsigned i = 0; i &lt; len; ++i) &#123; unsigned index = (unsigned)(word[i]-97); str_morse.append(morse[index]); &#125; morse_set.insert(str_morse); str_morse.clear(); &#125; return morse_set.size(); &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for Unique Morse Code Words.Memory Usage: 8.7 MB, less than 100.00% of C++ online submissions for Unique Morse Code Words.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-3]]></title>
    <url>%2F2019%2F04%2F07%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-3%2F</url>
    <content type="text"><![CDATA[ARTS week-3Algorithm[Leetcode]709. To Lower Case ReviewYour Productivity Hinges on How You Arrange Your Desk 你的工作效率取决于如何整理桌面 专注于实用 实践极简主义 基于你的工作和思考方式进行整理 要事放在最前面 实用多个屏幕 多一些绿色植物 适应“零桌面”习惯，保持整洁 将你的目标放在显眼的位置 放一张好看的照片 TipMac OS tags ，高效整理及访问文件或者文件夹； 最近频繁使用hexo blog 文件夹及对应的文章，还有一些整理过的文件夹，多级访问后，需要频繁点击鼠标，今天刚刚发现可以对不同的文件及文件夹进行Tag，打标签处理，将文件进行分类，快速访问。 Share[机器学习]线性回归公式推导]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[机器学习]线性回归公式推导]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[线性回归 公式推导线性回归是机器学习最基本的一个模型，接下来会写几篇各个模型的公式推导，后续再用代码实现下基本的模型运行。 矩阵表示数据集：D=\{(x_{1}, y_{1}),(x_{2}, y_{2}) \cdots (x_{m}, y_{m})\}​ x_{i} \in \mathbb{R^{n}}( n维)，y_{i} \in \mathbb{R}，i=1,2 \cdots m​ X=\begin{pmatrix} x_{1} & x_{2} & \cdots & x_{m} \end{pmatrix}^{T} =\ \begin{pmatrix} x^{T}_{1}\\ x^{T}_{2}\\ \vdots \\ x^{T}_{m} \end{pmatrix} =\begin{pmatrix} x_{11} & x_{12} & \cdots & x_{1n}\\ x_{21} & x_{22} & \cdots & x_{2n}\\ \vdots & \vdots & \ddots & \vdots \\ x_{m1} & x_{m2} & \cdots & x_{mn} \end{pmatrix}_{m*n}​Y=\begin{pmatrix} y_{1}\\ y_{2}\\ \vdots \\ y_{n} \end{pmatrix}_{n*1}，w= \begin{pmatrix} w_{1}\\ w_{2}\\ \vdots \\ w_{n} \end{pmatrix}_{n*1}​目标函数 f(x) = w^{T}X 其中，几个关键点需要注意： m表示样本数量，n 表示特征维度； W​ 的维度是和样本的特征维度一样的 默认情况下x_{i} 是列向量，但是样本矩阵X 中的每一个对应的样本是行向量； 另外可以增加一个偏置b，目标函数为f(x) = wx+b ，其中 w_{0} = 1, x_{0} =\begin{pmatrix} x_{01}\\ x_{02}\\ \vdots \\ x_{0n} \end{pmatrix}_{n*1}=b= \begin{pmatrix} b_{1}\\ b_{2}\\ \vdots \\ b_{n} \end{pmatrix}_{n*1} 这样表示后，其实f(x)=wx+b 也可以简化成f(x)=wx，x_{i}增加了一维而已，计算过程是不会有任何影响的，我们暂且使用f(x) = w^{T}X 来进行下述的推导。 损失函数： L( w) =\sum ^{m}_{i=1}\left\Vert w^{T} x_{i} -y_{i}\right\Vert ^{2}_{2} \\ =\sum ^{m}_{i=1}\left( w^{T} x_{i} -y_{i}\right)^{2}\\ =\begin{pmatrix} w^{T} x_{1} -y_{1} & w^{T} x_{2} -y_{2} & \cdots & w^{T} x_{m} -y_{m} \end{pmatrix}\begin{pmatrix} w^{T} x_{1} -y_{1}\\ w^{T} x_{2} -y_{2}\\ \vdots \\ w^{T} x_{m} -y_{m} \end{pmatrix}其中左边一项先做化简，右边相乘的是左边的转置： \begin{pmatrix} w^{T} x_{1} -y_{1} & w^{T} x_{2} -y_{2} & \cdots & w^{T} x_{m} -y_{m} \end{pmatrix} \\ =\begin{pmatrix} w^{T} x_{1} & w^{T} x_{2} & \cdots & w^{T} x_{m} \end{pmatrix} -\begin{pmatrix} y_{1} & y_{2} & \cdots & y_{m} \end{pmatrix}\\ =\ w^{T}\begin{pmatrix} x_{1} & x_{2} & \cdots & x_{m} \end{pmatrix} -\begin{pmatrix} y_{1} & y_{2} & \cdots & y_{m} \end{pmatrix}\\ =w^{T} X^{T} -Y^{T}\therefore \ L( w) =\left( w^{T} X^{T} -Y^{T}\right)\left( w^{T} X^{T} -Y^{T}\right)^{T}\\ =\left( w^{T} X^{T} -Y^{T}\right)( Xw-Y)\\ =w^{T} X^{T} Xw-w^{T} X^{T} Y-Y^{T} Xw+Y^{T} Y\\ =\ w^{T} X^{T} Xw-2w^{T} X^{T} Y+Y^{T} Y要求得损失函数L(w)的最小值所对应的w，就是求L(w)的导数为零的w的值； \frac{\partial L( w)}{\partial w} =2X^{T} Xw-2X^{T} Y=0\\ \therefore \ X^{T} Xw=X^{T} Y\\ \therefore w=\left( X^{T} X\right)^{-1} X^{T} Y今天先写到这，后续再更新下“几何解释”，未完待续… reference 线代随笔12-线性回归的矩阵推导 机器学习-白板推导系列-线性回归（Linear Regression） 最小二乘法-维基百科]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Machine Learning</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]709. To Lower Case]]></title>
    <url>%2F2019%2F04%2F01%2FLeetCode-709-To-Lower-Case%2F</url>
    <content type="text"><![CDATA[709. To Lower CaseImplement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. 题目很简单，说的就是英文字符串，转换成小写。 Example 1: 12Input: &quot;Hello&quot;Output: &quot;hello&quot; Example 2: 12Input: &quot;here&quot;Output: &quot;here&quot; Example 3: 12Input: &quot;LOVELY&quot;Output: &quot;lovely&quot; 方案一首先想到的就是遍历字符串，判断每一个字符是否是大写，如果是大写，则按照ASCII码，转换成小写后，添加到一个新的字符串里； 123456789101112131415class Solution &#123;public: string toLowerCase(string str) &#123; string out; for(char &amp;i : str) &#123; if ((i &gt;= 65) &amp;&amp; (i &lt;= 90)) &#123; i=i+32; out.push_back(i); &#125; else &#123; out.push_back(i); &#125; &#125; return out; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for To Lower Case. Memory Usage: 8.3 MB, less than 50.42% of C++ online submissions for To Lower Case. 结果看起来还可以，内存占用有点高，想着怎么优化一下； 方案二string out，占用了一个新建的字符串，是不是可以在原来的字符串里面修改？try try see. 12345678910111213class Solution &#123;public: string toLowerCase(string str) &#123; unsigned int len = str.length(); for(unsigned i = 0; i &lt; len; ++i) &#123; char ch = str[i]; if ((ch &gt;= 65) &amp;&amp; (ch &lt;= 90)) &#123; str[i]=ch+32; &#125; &#125; return str; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for To Lower Case. Memory Usage: 8 MB, less than 99.17% of C++ online submissions for To Lower Case. 内存占用降低了点，效果还可以。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-2]]></title>
    <url>%2F2019%2F03%2F31%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-2%2F</url>
    <content type="text"><![CDATA[ARTS week-2Algorithm[Leetcode]771.Jewels and Stones ReviewWhat I have learned after several AI projects 文章讲述了作者做AI项目的一些经验之谈 在进入AI浪潮之前，问自己三个问题： 你的业务是否是数据驱动 是否有合适并且有效的数据来支撑AI方案的实施 是否真正理解了AI是怎么工作的（如何产生效益） 小范围试错，没必要一开始就替换之前可以持续运行的系统，可能带来不可估量的损失； 知道自己想要什么，需要给AI一个明确的目标，这需要商业决策者和数据科学家共同理解并定义； AI项目的持续运行，除了架构、数据、算法外，更重要的是“人”，除了开发者，也包括使用这个AI系统，并给予真诚反馈的人； 数据集，并且是标注过的数据集，正确的数据集是关键； 基础设施：高性能的计算机，还有高带宽，高存储； AI是把双刃剑，能助你腾飞，也可能因此翻船。 Tip类Unix系统命令whatis，用来查询一个指定命令的简介信息，简要操作就像下面的动图一样。 Share读书笔记：《凤凰项目》（下）]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《凤凰项目》（下）]]></title>
    <url>%2F2019%2F03%2F30%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书笔记：《凤凰项目》（上） 上一篇讲了主人公从四种工作类型中理顺了工作流程，接下来我们看看续集… 比尔不仅弄清了所有工作流程中的瓶颈所在，也认定了“凤凰项目”在一群毫无章法的人和毫无流程可言的IT运营下，是一定会失败的；但是，这一切CEO都不会承认，却还斩钉截铁地认为“凤凰项目”一定可以成功，并且因此拯救公司； 果然，凤凰项目上线后，不仅没有为公司带来现金流，却带来了更多的麻烦；董事会给了公司管理人员三个月的时间，否则将进行公司的拆分，并把IT的工作外包出去； 公司的董事及对应的管理人员，经过慎重的考虑后，抽掉了各个单位的精英人才，经过过IT流程的详细梳理与慎重思考，启动了新的“独角兽”项目，并从一开始就把开发与运维混合在一起进行工作，不再是原来的开发与运维分离，先开发、后运维的方式；更为疯狂的是，完成了一个零所有人的瞠目结舌的目标：一天部署10次。 在开发运维的过程中，所有能自动化的事情都自动化了，包含了：开发测试，环境部署，监控报警，所有能脱离人工的，都脱离了人工；这些流程上的优化，大大加快了开发运维的速度，也减少了中间出现的问题。 “独角兽”项目上线之后大获成功，公司现金流大增，不仅挽救了公司，也挽救了CEO，比尔也从此走上了人生的另一个领地，开始走上公司的更高层。 这个挽救公司的过程中，作者梳理出了三步工作法： 第一工作法是关于从开发到IT运维再到客户的整个自左向右的工作流。为了使流量最大化，我们需要小的批量规模和工作间隔，绝不让缺陷流向下游工作中心，并且不断为了整体目标（相对于开发功能完成率、测试发现/修复比率或运维有效性指标等局部目标）进行优化。 必要的做法包括持续构建、集成以及部署，按需创建环境，严控半成品，以及构建起能够顺利变更的安全系统和组织。 第二工作法是关于价值流各阶段自右向左的快速持续反馈流，放大其效益以确保防止问题再次发生，或者更快地发现和修复问题。这样，我们就能在所需之处获取或嵌入知识，从源头上保证质量。 必要的做法包括：在部署管道中的构建和测试失败时“停止生产线”；日复一日地持续改进日常工作；创建快速的自动化测试套装软件，以确保代码总是处于可部署的状态；在开发和IT运维之间建立共同的目标和共同解决问题的机制；建立普遍的产品遥测技术，让每个人都能知道，代码和环境是否在按照设定的运行，以及是否达到了客户的目标。 第三工作法是关于创造公司文化，该文化可带动两种风气的形成：不断尝试，这需要承担风险并从成功和失败中吸取经验教训；理解重复和练习是熟练掌握的前提。 尝试和承担风险让我们能够不懈地改进工作系统，这经常要求我们去做一些与几十年来的做法大不相同的事。一旦出了问题，不断重复的日常操练赋予我们的技能和经验，令我们可以撤回至安全区域并恢复正常运作。 必要的做法包括营造一种勇于创新、敢于冒险（相对于畏惧或盲目服从命令）以及高信任度（相对于低信任度和命令控制）的文化，把至少20%的开发和IT运维周期划拨给非功能性需求，并且不断鼓励进行改进。 推荐大家阅读《凤凰项目》，从中了解流程的优化，项目的进化，也看看作者的心路历程，可能有一天，你我都可能会经历类似的事情，共勉。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>项目管理</tag>
        <tag>技术管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]771.Jewels and Stones]]></title>
    <url>%2F2019%2F03%2F26%2FLeetCode-771-Jewels-and-Stones%2F</url>
    <content type="text"><![CDATA[771. Jewels and StonesYou’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 解释一下题目： 在第二个字符串中，找出在第一个字符串中出现的字符的个数，其中，第一个字符串中的字符是不重复的。 思路：对于是否在第一个字符中出现，可以把第一个字符串的字符当做一个集合，再去判断元素是否在集合中，两个循环即可解决。 123456789101112131415161718class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int size = J.length(); set&lt;char&gt; jewel_set; for (unsigned int i = 0; i &lt; size; ++i) &#123; jewel_set.insert(J[i]); &#125; int count = 0; size = S.length(); for (unsigned int i = 0; i &lt; size; ++i) &#123; if (jewel_set.count(S[i])) &#123; count++; &#125; &#125; return count; &#125;&#125;; resultRuntime: 8 ms, faster than 74.17% of C++ online submissions for Jewels and Stones. Memory Usage: 9.9 MB, less than 54.58% of C++ online submissions for Jewels and Stones. 代码再简洁优化下，使用C++11的for循环，并且增加const限定符，程序快了，内存占用也降低了。 123456789101112131415161718class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int size = J.length(); set&lt;char&gt; jewel_set; for (const char &amp;ch : J) &#123; jewel_set.insert(ch); &#125; int count = 0; size = S.length(); for (const char &amp;ch: S) &#123; if (jewel_set.count(ch)) &#123; count++; &#125; &#125; return count; &#125;&#125;; resultRuntime: 4 ms, faster than 100.00% of C++ online submissions for Jewels and Stones. Memory Usage: 8.6 MB, less than 98.64% of C++ online submissions for Jewels and Stones.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《左耳听风》ARTS打卡计划-week-1]]></title>
    <url>%2F2019%2F03%2F24%2F%E3%80%8A%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E3%80%8BARTS%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92-week-1%2F</url>
    <content type="text"><![CDATA[ARTS week-1Algorithm[Leetcode]21.Merge Two Sorted Lists ReviewI’m Leaving Google — Here’s the Real Deal Behind Google Cloud 作为一个已经离开Google的人，作者说了一些自己在谷歌云当项目经理的种种体会与感想；更是给了Google很高的评价，希望自己的三个儿子都可以在Google开始他们的职业生涯，因为Google提供了在大多数重要的科技领域中，快速学习与发展的机会。 Google是工程师和项目经理的天堂 高水平的工程师与项目经理，牛人聚集，从来不缺智慧与经验，创造着各种各样不可思议的产品，但是也绝对不会忽略员工的个人发展，有着很好的个人职业规划。 千金难买好文化 所有信息都是可以公开获得的，每周与创始人及高管的对话，另外之前也听说过，Google的代码对于所有入职员工都是可以随意访问的；同事之间的互助与合作很融洽，内部有各种不同的论坛，都能很及时的得到各种帮助。 融为一体的创新与规模 既有创新，有能将小小的创新最后做成规模化的产品服务大众。 以为Google只是这样止步以此？在AWS和AZure的夹击下，Google依然迎头赶上，做出了Google Cloud，通过大家的努力，也赢得了一些不同需求的客户，走在做强做大的道路上。 文章中出现的一些英文缩写，比如IMO，一开始并不知道什么意思，查了之后，才知道是In My Opinion的意思，附上查询英文缩写的网站 https://www.acronymfinder.com/ Tipssh指定端口及免密登录 去年4.1号用gcp搭的梯子，下周就过期了，这周新建了gcp进行梯子的搭建，将gcp默认的ssh端口22修改成了其他数字，在ssh命令后面增加-p参数，即可更改； 以前使用ssh时，都是使用用户名密码进行登录，但是gcp默认没有设置对应的密码，查过一番后，是可以免密登录的，创建对应的公钥和私钥，ssh命令后面增加-i参数，指定对应的私钥，在gcp的元数据中，增加对应的公钥，即可实现免密登录，拷贝私钥到不同的电脑上，还可以实现在多台电脑上能进行ssh的免密登录，后续维护vps也更方便了。 假设私钥是private-ssh-key，端口是12345，命令就类似下面这样，生成公钥、私钥对，使用“ssh-keygen”命令，具体再详细google或者查man手册。 1ssh -i private-ssh-key -p 12345 username@192.168.1.123 Share读书笔记：《凤凰项目》（一）]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：《凤凰项目》（上）]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E3%80%8A%E5%87%A4%E5%87%B0%E9%A1%B9%E7%9B%AE%E3%80%8B%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[《凤凰项目》讲述了一个IT运维的传奇故事，一位IT经理临危受命，经过多番努力，将公司从死亡边缘拉了回来。跌宕起伏的故事情节，也生动地描述了现代IT组织的管理过程中可能遇到的各种事件，服务中断、服务器崩溃、数据丢失、客户隐私数据泄露、办公室政治的博弈等等；想得到与想不到的事均穿插其中；但是从始至终有一条线很清晰，就是主人公一直在通过各种方法，来改善公司以往破旧不堪且岌岌可危的IT系统，以此来支撑公司的持续高效运营。 主人公比尔临时被推上了IT副总裁的位置，开始看到这个公司的IT管理的混乱不堪，一切都毫无章法，项目任务归属不清、IT变更没有记录、紧急状况没有预案、安全合规更是无稽之谈；他开始尝试梳理所有事情，让一切慢慢变得清晰起来， 列出目前所有项目，各个项目对应的事项 列出目前正在运维的项目 列出所有需要变更的事项 整理出了一堆表格与列表后，他终于有点摸清了整个IT运维的相关事情，并对各种项目做了优先级排列，需要变更的事项也根据优先级做了分类； 在这一切都有条不紊地进行时，却时不时出现不同原因导致的服务中断，相关人员不得不停下手上的工作，投入到救火的队伍中，此时，他发现自己漏了一个很大的工作事项，就是“计划外工作”，也可称为“救火的工作”，这时，他总算摸清了四种类型的IT运维工作，分别是： 业务项目（新项目部署、调试、上线） IT运维项目（已上线项目新增的运维任务） 变更任务（运维变更，bug修复变更，需求变更） 计划外工作（紧急bug，宕机，服务中断） 项目管理中的两大需要梳理清楚的东西： 人：有多少人，这些人能干什么事，能做多少事； 事：有多少事，这些事需要什么人来干，需要多少人来干； 另外还有一个很关键的因素穿插其中，那就是“时间”，时间是一个很魔幻的东西，毕竟有些事，不是有人就可以做得成的，有一个比较极端的例子就是：一个女人十月怀胎生出一个娃，但是千万别想让十个女人一个月生出一个娃。 在时间不够的情况下，如果没有办法加时间，那就要砍需求、去除部分非核心功能，如果功能不允许去除，那就得忍受项目上线有bug，而且可能是影响客户体验的bug；不可能在有限的时间里，既要实现功能，又要有质量保障，那就基本是不可能的事儿了，纯属天荒夜谈。 故事到这，讲了基本的四种工作类型是什么，过程中，注重的是理清流程、梳理任务、分门别类，为下一步工作做好铺垫。 接下来是力挽狂澜，顺风顺水，还是屡战屡败，越挫越勇，故事还没看完，下回接着讲…]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>项目管理</tag>
        <tag>技术管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]21.Merge Two Sorted Lists]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode-21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 给定有序的两个数组，合并两个数组，并保持有序。这其实是归并排序的其中一个步骤。 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1 == NULL &amp;&amp; l2 == NULL) return NULL; if(l1 == NULL &amp;&amp; l2 != NULL) return l2; if(l1 != NULL &amp;&amp; l2 == NULL) return l1; ListNode* result; if (l1-&gt;val &lt;= l2-&gt;val) &#123; result = l1; l1 = l1-&gt;next; result-&gt;next = mergeTwoLists(l1, l2); &#125; else &#123; result = l2; l2 = l2-&gt;next; result-&gt;next = mergeTwoLists(l1, l2); &#125; return result; &#125;&#125;; tip: 两个参数是否空指针需要判断 result提交过程错了两次，一次是因为空指针，一次是因为判断大小的语句里，还多余判断了一次下一个元素是不是空指针，导致少了个元素。 Runtime: 20 ms, faster than 9.56% of C++ online submissions for Merge Two Sorted Lists.Memory Usage: 9.9 MB, less than 88.65% of C++ online submissions for Merge Two Sorted Lists. 内存占用太大，还有改进空间。 有个疑惑，其中一段代码改成以下这样后，内存占用竟然升高到10.1M 1234567if (l1-&gt;val &lt;= l2-&gt;val) &#123; result = l1; result-&gt;next = mergeTwoLists(l1-&gt;next, l2); &#125; else &#123; result = l2; result-&gt;next = mergeTwoLists(l1, l2-&gt;next); &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 内置数据结构（一）]]></title>
    <url>%2F2018%2F07%2F29%2FPython-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[从上一篇“Python入坑指北”开始，一系列的Python文章，是关于Python的学习笔记，参考书是《Python for Data Analysis, 2nd Edition》，github的仓库有详细的jupyter notebook（https://github.com/wesm/pydata-book）。 元组（tuple）1.1 初始化123456789# 初始化tup1 = 4, 5, 6print(tup1)tup2 = 'hello', [1, 3], (4, 6), 0.5, 1, 1==1, &#123;'a':1, 'b':2&#125;print(tup2)tup3 = tuple([4, 0, 2])print(tup3)print(tuple('string'))print(tuple(['foo', [1, 2], True])) 以上代码输出结果： 12345(4, 5, 6)('hello', [1, 3], (4, 6), 0.5, 1, True, &#123;'a': 1, 'b': 2&#125;)(4, 0, 2)('s', 't', 'r', 'i', 'n', 'g')('foo', [1, 2], True) 可以看出几个重要的点： 元素以逗号“,”分割，以括号( )包含一个元组的所有元素； 一个tuple里面可以同时容纳多种类型的元素，且不需要声明tuple类型 可以使用list进行tuple的初始化； 可以将一个string转化为tuple； 1.2 元素访问123456tup1 = tuple('string')print(tup1[0])tup2 = tuple(['foo', [1, 2], True])tup2[1].append(3)print(tup2)tup2[2] = False 以上代码输出结果： 123456s('foo', [1, 2, 3], True)Traceback (most recent call last): File "ch3_1.py", line 6, in &lt;module&gt; tup2[2] = FalseTypeError: 'tuple' object does not support item assignment 我们总结下访问的几个注意事项： 使用中括号 [ ] 进行元组元素的访问； 元组中元素只可读，不可写； == ，说好的元素只读，那上面代码的第4行是怎么回事，为什么还能添加一个元素？其实tup2[1]指向的是一个list，在这里是元素指向的list不可变，list本身是可以变更的。 1.3 元组的解包 (Unpacking tuple)12345678910111213141516171819202122232425tup = (4, 5, 6)a, b, c = tupprint(b)tup = (4, 5, (6, 7))a, b, (c, d) = tupprint(d)# 交换变量赋值a, b = 1, 2b, a = a, bprint(a, b)# 用于元组和数组的迭代解包seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]for a, b, c in seq: print('a=&#123;0&#125;, b=&#123;1&#125;, c=&#123;2&#125;'.format(a, b, c)) # 函数的多返回值values = 1, 2, 3, 4, 5a, b, *rest = valuesprint(a, b)print(rest)# 如果rest此时是不需要使用的变量，可以如下表示，使用‘_’当做占位符a, b, *_ = values 以上代码输出结果： 12345678572 1a=1, b=2, c=3a=4, b=5, c=6a=7, b=8, c=91 2[3, 4, 5] 元组的解包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接收这些元素的元组的空档数一致；也可以用*来表示忽略多余的元素（如上代码所述）； 一般的迭代对象包括：元组，列表，字典，字符串。 1.4 常用类方法如果在ipython中或者Jupyter notebook中，使用TAB键就能列出tuple的类方法，下面说几个常用方法； 123tup = (1, 2, 3, 3)tup.count(3) # 计算3在tuple中的个数tup.index(2) # 返回第一个2在tuple中的位置 列表（list）与tuple相比，list就是可变长的，可直接修改相应元素的对象，使用中括号 [] 进行初始化。 2.1 初始化 自定义初始化list 123456a_list = [2, 3, 7, None]tup = ('foo', 'bar', 'baz')b_list = list(tup)print(b_list)b_list[1] = 'peekaboo'print(b_list) 列表和元组在语法上有点类似，list可以直接从tuple初始化得到，两者之前最大的差异就是可修改与不可修改； 以上代码执行的结果如下，可以看到第5行代码修改了list的第二个元素 12['foo', 'bar', 'baz']['foo', 'peekaboo', 'baz'] list常用来实现一个迭代器或者生成表达式： 1234gen = range(10)print(gen)g_list = list(gen)print(g_list) 输出结果如下： 12range(0, 10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 2.2 添加和删除元素12345678910111213b_list = ['foo', 'bar', 'baz']b_list.append('dwarf') # 末尾添加元素print(b_list)b_list.insert(1, 'red') # 指定index添加元素print(b_list)b_list.pop(2) # 指定index删除元素print(b_list)b_list.append('foo') # 末尾添加元素print(b_list)b_list.remove('foo') # 删除第一个fooprint(b_list)print('dwarf' in b_list) # 判断dwarf是否在list中print('dwarf' not in b_list) 可以看到，添加元素有append, insert方法，删除元素有pop, remove方法，其他有关list的方法，可以在ipython中使用TAB键进行查看； 如果不考虑性能，可以使用append和remove，不然可以使用Python的另外一个数据结构 ‘multiset’，以此来优化性能； 输出结果： 1234567['foo', 'bar', 'baz', 'dwarf']['foo', 'red', 'bar', 'baz', 'dwarf']['foo', 'red', 'baz', 'dwarf']['foo', 'red', 'baz', 'dwarf', 'foo']['red', 'baz', 'dwarf', 'foo']TrueFalse 2.3 列表的拼接和组合1234print([4, None, 'foo'] + [7, 8, (2, 3)])x = [4, None, 'foo']x.extend([7, 8, (2, 3)]) # 已定义的list，使用extend进行扩展组合print(x) 以上代码输出结果： 12[4, None, 'foo', 7, 8, (2, 3)][4, None, 'foo', 7, 8, (2, 3)] 列表的拼接 “+” 会创建出一个新的对象并进行拷贝，如果构造了一个数据量大的列表，再对其进行copy操作，将会非常影响性能，此时建议使用extend进行扩展组合操作； 1234567everything = []for chunk in list_of_lists: everything.extend(chunk)# 上面这个操作肯定比下面这个要更快everything = []for chunk in list_of_lists: everything = everything + chunk 2.4 排序 排序 123456a = [7, 2, 5, 1, 3]a.sort()print(a)b = ['saw', 'small', 'He', 'foxes', 'six']b.sort(key=len) # 按元素长度排序print(b) 输出结果： 12[1, 2, 3, 5, 7]['He', 'saw', 'six', 'small', 'foxes'] 注意：列表排序并不需要重新创建对象，直接在原有对象上进行操作（in-place）； 二分查找与有序列表维护 Python内置 bisect模块实现了有序列表的二分查找和插入，看下以下几个操作： 123456import bisectc = [1, 2, 2, 2, 3, 4, 7]print(bisect.bisect(c, 2)) # the same of bisect_right 获取'2'这个元素在列表中即将插入的indexprint(bisect.bisect(c, 5))bisect.insort(c, 6) # the same of insort_rightprint(c) 注意： bisect 方法仅获取了index，并没有对元素进行插入操作； bisect模块并不会对list进行判断是否有序，所以，使用前需要进行排序，否则可能出现操作返回错误的结果； 以上代码执行结果： 1234 # 优先靠右，所以获取到的index为46[1, 2, 2, 2, 3, 4, 6, 7] 2.5 切片12345678910seq = [7, 2, 3, 7, 5, 6, 0, 1]print(seq[1:5]) # not included seq[5]seq[3:4] = [6, 3] # 替换 index 为 3,4 的两个元素为 6,3print(seq)print(seq[:5]) # start不填，默认从0开始print(seq[3:]) # start不填，默认到末尾print(seq[-4:]) # 倒数第4个开始，到末尾print(seq[-6:-2]) print(seq[::2]) # 正序，步长为2print(seq[::-1]) # 倒序，步长为1，the same of seq.reverse() [start:stop:step]，左闭右开，包含start开始的元素，不包含stop的元素 12345678[2, 3, 7, 5] [7, 2, 3, 6, 3, 5, 6, 0, 1][7, 2, 3, 6, 3][6, 3, 5, 6, 0, 1][5, 6, 0, 1][6, 3, 5, 6][7, 3, 3, 6, 1][1, 0, 6, 5, 3, 6, 3, 2, 7] 内置序列函数（Built-in Sequence Functions）Python包含三种主要的序列类型：list, tuple, range；还有其他的序列类型，包含二进制数据（binary data）和文本字符串（text strings）； 3.1 enumerate按照以往循环一个列表可能的操作是下面这样： 1234i = 0for value in collection: do something with value i += 1 Python内置了枚举操作，并返回对应的index和value： 12345some_list = ['foo', 'bar', 'baz']mapping = &#123;&#125;for i, v in enumerate(some_list): mapping[v] = iprint(mapping) # &#123;'bar': 1, 'baz': 2, 'foo': 0&#125; 3.2 sorted12print(sorted([7, 1, 2, 6, 0, 3, 2]))print(sorted('horse race')) 数字默认从大到小排序，字符串默认字母顺序排序 12[0, 1, 2, 2, 3, 6, 7][' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's'] 3.3 zipzip将两组或者多组可迭代的对象打包成一对对的元组 1234567seq1 = ['foo', 'bar', 'baz']seq2 = ['one', 'two', 'three']zipped = zip(seq1, seq2)list(zipped) # [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]seq3 = [False, True]# 打包出来的大小取决于最小的序列大小，即为2list(zip(seq1, seq2, seq3)) # [('foo', 'one', False), ('bar', 'two', True)] 两种常用的zip方法： 12345678910111213# 与enumerate结合for i, (a, b) in enumerate(zip(seq1, seq2)): print('&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'.format(i, a, b))# 0: foo, one# 1: bar, two# 2: baz, three# 解包(unzip)的另一种操作，也可进行数据的行列相互转换pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'), ('Schilling', 'Curt')]first_names, last_names = zip(*pitchers)first_names #('Nolan', 'Roger', 'Schilling')last_names #('Ryan', 'Clemens', 'Curt') 3.4 reversed1list(reversed(range(10))) # 序列翻转 注意：reversed是个生成表达式(generator)，需要搭配list或者for循环使用，reversed()本身返回的是一个迭代器对象。 下一篇文章会介绍一下其他的内置数据结构，包含字典（dict）、集合（set），以及他们和list的对比；才疏学浅，如有错误，还望联系并指出。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 入坑指北]]></title>
    <url>%2F2018%2F07%2F11%2FPython-%E5%85%A5%E5%9D%91%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[Python 入坑指北 1. 几个问题 2. 环境相关 2.1 Anaconda 2.2 IPython 2.3 Jupyter Notebook 3. Python语言基础 4. 思维导图 Python 入坑指北1. 几个问题 使用Python2 还是Python3？ 为什么安装Python package的时候出现各种莫名其妙的错误？ 怎么增加一个第三方的package，很多包还有多级的依赖关系，如何更好解决？ 2. 环境相关2.1 Anaconda什么是Anaconda，有什么优点？ Anaconda 是python的一个发行版，包含了conda、python和大量的数据科学相关的库，官方网站的主标题是：The Most Popular Python Data Science Platform； 其中Conda是一个管理工具，可以管理多种语言的包、依赖和环境；包含Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN；如果开发中需要同时使用Python2和Python3，Conda可以轻松帮你搞定不同版本之间的环境切换，也可轻松管理不同版本的包，这下安装包的时候就so easy，再也不会出现特别多的莫名其妙的错误了； Anaconda包含了Conda、Python和大量的数据科学相关的库，如果不需要那么多库，也可以选择Miniconda进行安装； 123456789101112# 安装一个packageconda install pkg_name# 同时安装多个packageconda install numpy scipy pandas# 安装指定版本的packageconda install numpy=1.10# 移除一个packageconda remove pkg_name# 升级conda update# 查看所有packageconda list 下面再看下用conda管理不同的python版本环境； 12345678910111213141516# 创建一个python2.7版本的环境并安装pandas包conda create -n py2 python=2.7 pandas# 执行后你会发现，conda自动帮你把所有pandas依赖的包都装好了# 进入py2环境（windows使用 activate py2)source activate py2# 退出当前环境（windows使用 deactivate)source deactivate# 删除环境conda env remove -n py2# 列出所有创建的环境conda env list# 如果分享python代码需要分享同样的开发环境的时候，可以讲当前环境导出conda env export &gt; environment.yaml# 从YAML文件创建环境conda env create -f environment.yaml 环境相关的内容就到此，有了Anaconda，基本就不用再操心所谓的版本冲突问题，包安装问题，集成好的管理环境，也就不再需要烦恼环境问题，把精力耗费在写代码吧。 2.2 IPythonIPython是一种基于Python的交互式解释器；相较于原生的Python Shell，IPython提供了更为强大的编辑和交互功能。拥有诸多优点： 帮助信息完善，且支持模糊匹配（print?, print??, np.*load*?）；对象后面添加问号，一样能列出相关信息（称为对象的内省）； 支持TAB补全代码，使用历史输入（%history/%hist/hist命令） %run运行外部python脚本，%load加载外部python脚本，%paste运行剪贴板内容； 支持shell的终端快捷键； magic command（%timeit, %debug?, %pwd, etc…）； %matplotlib inline 可视化图内置显示； 2.3 Jupyter NotebookJupyter Notebook （此前被称为 IPython notebook）是个开源的Web应用，可以创建和分享包含代码、方程式、可视化界面和文本的文档，拥有以下优点： 可选择的语言：支持运行40 多种编程语言，包含Python、R、Julia、Scala等； 分享文档：可通过邮件、Dropbox、Github、Jupyter Notebook Viewer分享创建的文档； 交互式输出：代码可以生成丰富且带交互式的输出结果，包括HTML、图片、视频、LaTeX还有自定义的MIME格式； 大数据集成：通过Python、R或者Scala，使用例如Apache Spark等大数据工具，使用pandas、scikit-learn、 ggplot2、TensorFlow等对同一份数据进行处理； Jupyter Notebook 还有很多可以探寻的功能，比如可以远程访问等，具体操作慢慢探索。 jupyter notebook —no-browser 启动时不自动启动浏览器 jupyter notebook —generate-config 生成配置，修改访问IP，增加密码登录等 3. Python语言基础 缩进分割（4个空格），不像C++、Java使用分号分割每一个执行语句 没有括号，循环及控制语句使用冒号(:) 不建议赋值语句写在同一行，例如a = 5; b = 6; c = 7 一切皆对象 注释：使用#开头 动态数据类型，a=5，在不用重新声明的情况下，a=’foo’也是对的 强类型，a=5;b=’5’; a+b就会报错，在弱类型语言中(php,js,perl)会进行隐式转换 可变和不可变对象 可变对象 lists dicts NumPy arrays 不可变对象 string tuples 标量/原子类型 None str ‘hello’ “world” 多行使用’’’或者””” bytes Bytes Unicode float 除法：3/2=1.5, 3//2=1 bool True False int 类型转换 Dates and times 控制流 if, elif, and else for loops for value in collection: for a,b,c in iterator: while loops pass range 三元表达式(Ternary expressions) value = true-expr if condition else false-expr 内置函数 __builtin__ 查看所有内置函数 dir(__builtin__) 查看某个类的内置方法 dir(list) dir(tuple) 4. 思维导图以上内容整理简介的思维导图，以供后续复习：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计那些事]]></title>
    <url>%2F2018%2F06%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[概述数据库设计作为DBA的重要一课，也是作为开发人员认识数据库的一个基本课程，在左耳朵耗子的极客时间课程里，推荐了慕课网的《数据库设计那些事》，此文是学习的总结，画了完整的一个思维导图，如有错误，还望联系并指出。 思维导图]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库设计</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python之路(一)数组和元组]]></title>
    <url>%2F2018%2F04%2F15%2FPython%E4%B9%8B%E8%B7%AF(%E4%B8%80)%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Python作为一种解释型语言，拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。从1991年第一个版本发布，到如今驰骋编程语言界近三十载，最近更是如火如荼，特别是这一波人工智能的兴起，将原本已经横跨多个领域（web开发，GUI开发，数据分析，数据可视化，人工智能）的Python，推向了一个新高度。 废话不多说，按 Linus 的话说： Talk is cheap, show me the code. 以下相关代码均在Python3.6环境下验证通过。 1234567891011121314151617181920#可使用不同的类型进行数组的初始化，无需像C++/Java必须同种类型才能同属一个数组my_list = [1, 3, 5, 7, "hello", 'one', 3.14] li = [1,2,3] # 初始化li.append(4) # 在数组最后添加一个元素4for item in li:print(item)print('========')for i in range(len(li)):print(li[i])print('========')print(li[0]) # 打印数组的第一个元素1print(li[1]) # 打印数组的第二个元素2print(li[-1]) # 打印数组的最后一个元素4li.append([5,6]) # 将[5,6]数组当做一个整体添加到数组最后print(li[-1]) # 打印数组最后一个元素 [5,6]li.extend([7,8]) # 将[7,8]数组内元素展开并添加到li中，而不是将[7,8]当做一个元素print(li[-1]) # 打印数组最后一个元素 8 输出结果： 1234567891011121314151234========1234========124[5, 6]8 上面一段代码列了基本的数组操作，访问元素，循环输出，其中li[-1]这种特殊的访问方式，在C/C++和Java中是没有的，可以从另一个方面理解，就是li[len(li) - 1]，只不过省略了len(li)。 接下里看下和数组有很多相似的元组tuple使用括号 () 进行初始化，只可读，不可写123456tp = (1, 3, 5, 'hello', 5.5, "one")print(tp)t = ('a', 'b', ['A', 'B'])t[2][0] = 'X't[2][1] = 'Y'print(t) 输出结果： 123(1, 3, 5, &apos;hello&apos;, 5.5, &apos;one&apos;)(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 说好的只读呢，这里应该理解成元素指向的不可变，第2个元组指向还是一个数组，只不过是数组内部元素发生了改变。 今天就到这。。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集和字符编码]]></title>
    <url>%2F2017%2F03%2F02%2F%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[历史与渊源：当计算机由美国人发明后，当时设计到字符输入，由于是英文字符，通过收集整理。他们形成了标准的ASCII码(128) 字符集。8位，首位为0。由于不断普及，欧洲西方国家相应使用，发现有些特殊字符它们不能表示，如：λφ等。如是出来想法，想利用 ASCII 码后128位，增加它们的字符。这样就出现了EASCII码。这些还是不能表示所有国家，像法语，俄语等有自己特殊字符。因此制定标准将后128位进行分片制定。制定出iso-8859系列字符集。 ISO/IEC 8859-1 (Latin-1) - 西欧语言ISO/IEC 8859-2 (Latin-2) - 中欧语言ISO/IEC 8859-3 (Latin-3) - 南欧语言。世界语也可用此字符集显示。ISO/IEC 8859-4 (Latin-4) - 北欧语言ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言ISO/IEC 8859-6 (Arabic) - 阿拉伯语ISO/IEC 8859-7 (Greek) - 希腊语ISO/IEC 8859-8 (Hebrew) - 希伯来语（视觉顺序）ISO 8859-8-I - 希伯来语（逻辑顺序）ISO/IEC 8859-9（Latin-5 或 Turkish）- 它把Latin-1的冰岛语字母换走，加入土耳其语字母。ISO/IEC 8859-10（Latin-6 或 Nordic）- 北日耳曼语支，用来代替Latin-4。ISO/IEC 8859-11 (Thai) - 泰语，从泰国的 TIS620 标准字集演化而来。ISO/IEC 8859-13（Latin-7 或 Baltic Rim）- 波罗的语族ISO/IEC 8859-14（Latin-8 或 Celtic）- 凯尔特语族ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元（€）符号。ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。 整出了这么多的字符集，说到底还是不够用；当计算机在中日韩等国家兴起的时候，这些字符集面对成千上万的中日韩字符，就显得有点力不从心了，像中国常见汉字有7000多个，扩展128个空位，完全不够。因此，需要用多个字节表示。后来就约定，第一个字节，第一位如果是1，后面还有一个字节与之一起表示一个字符。如果是0，就对应 ASCII 码。这样就形成了国内的GB2312，后来还是不够表示繁体中文，加入了繁体的字符形成了GBK；在GBK的基础上，又增加了6351个字符，其中一部分为4字节字（four-byte encoding range），增加了六种少数民族语言和一些四字节字，形成了GB18030-2000。但是，这样全世界各个国家还是用它们自己字符集进行表示。没有一个统一的大字符集，能够表示全球所有字符。 在 1991 年，国际标准化组织和统一码联盟组织各自开发了 ISO/IEC 10646（USC）和 Unicode 项目。各自都想将项目作为世界标准，不过很快双方都意识到世界上并不需要两个不兼容的字符集。于是他们就编码问题进行了一次非常友好地会晤，决定彼此把工作内容合并，项目依然独立存在，各自发布各自的标准，前提是两者必须保持兼容。不过由于 Unicode 这一名字比较好记，因而它使用更为广泛，成为了事实上的统一编码标准。 此时此刻，世界就如大家想像般地合并了，天下大一统。 Unicode与USCUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。 UTF-32/ UTF-16/ UTF-8 都是将数字转换到程序数据的编码方案。 我们平常所说的Unicode，通常是指Unicode字符集；从另一个层面来说，Unicode还有它的编码方案，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。 说完Unicode，就得再谈一下USC和Unicode的关系； Unicode 字符编码标准与 ISO 10646 的通用字符集（Universal Character Set，UCS）概念相对应，目前的用于实用的 Unicode 版本对应于 UCS-2，即使用16位来表示一个Unicode字符。也就是每个字符占用2个字节。这样理论上一共最多可以表示65,536(2的16次方) 个字符。基本满足各种语言的使用。实际上目前版本的 Unicode 尚未填充满这16位编码，保留了大量空间作为特殊使用或将来扩展。未来版本会扩充到 ISO 10646-1 实现级别3，即涵盖 UCS-4 的所有字符。UCS-4 是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示2,147,483,648(2的31次方)个字符，完全可以涵盖一切语言所用的符号。 UTFUTF：Unicode（UCS）只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字“严”的unicode（UCS）码是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。 这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。为了解决这些问题，就出现了UTF。 UTF（Unicode Translation Format），它是Unicode （UCS）的实现（或存储）方式，称为Unicode转换格式。Unicode 的实现方式不同于编码方式。一个字符的Unicode 编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。UTF有三种实现方式： UTF-16：其本身就是标准的Unicode编码方案，又称为UCS-2，它固定使用16 bits(两个字节)来表示一个字符。 UTF-32：又称为UCS-4，它固定使用32 bits(四个字节)来表示一个字符。 UTF-8：最广泛的使用的UTF方案，UTF-8使用可变长度字节来储存Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。UTF-8更便于在使用Unicode的系统与现存的单字节的系统进行数据传输和交换。与前两个方案不同：UTF-8以字节为编码单元，没有字节序的问题。 UTF有三种方案，那么如何在接收数据和存储数据时识别数据采用的是哪个方案呢？Unicode（UCS）规范中推荐的标记字节顺序的方法是BOM。BOM不是“Bill Of Material”的BOM表，而是Byte order Mark。 在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”（零宽度非换行空格）的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不会出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。Windows就是使用BOM来标记文本文件的编码方式的。 这样根据识别前面的”ZERO WIDTH NO-BREAK SPACE”字符即可识别编码方案，字节流中前几个字节所表示的编码方式如下： EF BB BF ———— UTF-8 FE FF ————UTF-16/UCS-2, little endian FF FE ————UTF-16/UCS-2, big endian FE FF 00 00 ————UTF-32/UCS-4, little endian. 00 00 FF FE ————UTF-32/UCS-4, big-endian. 实例大 Unicode编码为0x5927，可以通过Unicode中文编码表查到，用LoveString查看就是下图的结果： 在Ubuntu中用Python查看，如下图： 最后我们将单个中文字‘大’，用编辑器存储成不同的编码格式，再仔细看看对应的二进制： 图中显示的BOM字符，就是按照上述所说的顺序来显示了。 以上就是关于字符集和字符编码的整理与个人理解，不一定完全正确，如果有什么错误的地方，还望海涵并指出，互相学习，积极思考。 Reference字符集和字符编码（Charset &amp; Encoding） 字符集与字符集编码简介 wiki Unicode 百度百科 Unicode Byte order mark 阮一峰老师文章的常识性错误之 Unicode 与 UTF-8]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>字符集</tag>
        <tag>字符编码</tag>
        <tag>UTF8</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫之豆瓣电影TOP250]]></title>
    <url>%2F2017%2F02%2F18%2FPython%E7%88%AC%E8%99%AB%E4%B9%8B%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250%2F</url>
    <content type="text"><![CDATA[学习爬虫的最初始原因是为了抓取一些想要的信息，也是为了后续学习机器学习相关内容积累一些数据处理方面的知识；废话不多说，上代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# __author__ = 'c1rew'# -*- coding: utf-8 -*-import requestsfrom bs4 import BeautifulSoupimport reimport timeimport pymysql.cursorsheader = &#123;'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36'&#125;urls = ['https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(str(i)) for i in range(0, 250, 25)]movies = []def parse_one_movie(cursor, infos): url = infos.find("a", href=re.compile(r"https://movie\.douban\.com/subject/[0-9]+/"))['href'] titles = infos.findAll("span", class_="title") title = "" if isinstance(titles, list): for item in titles: title = title + item.get_text() else: title = titles.get_text() other_title = infos.find("span", class_="other").string[3:] # delete / and space rating_num = infos.find("span", class_="rating_num").string movie_info = infos.find("div", class_="bd").p.get_text().strip() movie_infos = movie_info.split('\n') director_actor = movie_infos[0].strip() other_infos = movie_infos[1].strip().split('/') if len(other_infos) == 3: year = other_infos[0].strip() region = other_infos[1].strip() movie_type = other_infos[2].strip() else: # for 82 大闹天宫 year = other_infos[0].strip() +"," + other_infos[1].strip() + "," + other_infos[2].strip() + "," + other_infos[3].strip() region = other_infos[4].strip() movie_type = other_infos[5].strip() introduce = infos.find("span", class_="inq") # 有电影的简介是空的，这里容错下 if introduce != None: introduce = introduce.string else: introduce = "" movie = [title,\ other_title,\ url,\ rating_num,\ director_actor,\ year,\ region,\ movie_type,\ introduce] movies.append(tuple(movie))def get_url_info(cursor, url): url_info = requests.get(url, header) content = url_info.content.decode('utf-8') soup = BeautifulSoup(content, "html.parser") items = soup.findAll("div", class_="item") for item in items: parse_one_movie(cursor, item) time.sleep(1) # 一次网页请求间隔1m，防止被禁sql_create = "CREATE TABLE IF NOT EXISTS douban_top_movie " \ "( ID INT NOT NULL AUTO_INCREMENT, " \ " PRIMARY KEY(ID), " \ " title VARCHAR(128), " \ " other_title VARCHAR(128), " \ " url VARCHAR(512), " \ " rating_num VARCHAR(64), " \ " director_actor VARCHAR(1024), " \ " year VARCHAR(64), " \ " region VARCHAR(128), " \ " movie_type VARCHAR(128), " \ " introduce VARCHAR(1024)" \ ");"# 连接本地mysql数据库，mysql.server需要保证已启动connection = pymysql.connect(host='localhost', user='root', password='', db='douban_infos_db', charset='utf8mb4')try: with connection.cursor() as cursor: cursor.execute(sql_create) #从list中获取一个网页，一次解析25个电影 for url in urls: print(url) get_url_info(cursor, url) sqlcmd = '''insert into douban_top_movie ( title, other_title, url, rating_num, director_actor, year, region, movie_type, introduce ) values(%s, %s, %s, %s, %s, %s, %s, %s, %s)''' cursor.executemany(sqlcmd, movies) connection.commit()finally: connection.close() 代码运行环境： Python 3.5.2 |Anaconda 4.2.0 (x86_64) Mac mini macOS Sierra Version 10.12.2 如果本地运行环境不一致，可能会出现一些错误，到时候再对应调整一下，如果不用MySQL存储数据，也可以使用Redis或者Excel表格也行。 MySQL相关命令行中使用sql语句导出时，MySQL报错了：1The MySQL server is running with the --secure-file-priv option so it cannot execute this statemen google了一番，发现是MySQL的配置问题，需要修改/etc/my.cnf 如果这个目录下没有这个文件，就到MySQL的安装目录下去拷贝默认的一份配置，我的Mac是在下面的路径里： /usr/local/Cellar/mysql/5.7.17/support-files/my-defalult.cnf 拷贝过去后，在my.cnf的最后增加一句 secure_file_priv=”” 接下来再使用sql语句将之前已入库的数据导出csv表格，以便后续上传到BDP做简单的数据统计分析 12345SELECT * FROM douban_top_movie INTO OUTFILE '~/work/topmovie.csv' FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n'; 数据分析仅仅挑选了几个比较好展示的数据，没有对类型进行分词处理，不然是可以对类型做一个饼图，这样效果是会好一些； Reference写这个代码的过程中，参考了一些类似资料，也是在学习Python爬虫课的过程中记录下练习过程； 推荐下七月在线的课，打折的时候还是有很多优惠：七月在线 （PS: 无利益相关哈！！） 以下是一些参考链接： python爬虫之豆瓣音乐top250 Python爬虫之Xpath学习 Python MySQL数据库操作]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率为0的事件，必然不能发生吗？]]></title>
    <url>%2F2016%2F10%2F09%2F%E6%A6%82%E7%8E%87%E4%B8%BA0%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%BF%85%E7%84%B6%E4%B8%8D%E8%83%BD%E5%8F%91%E7%94%9F%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[记录下这个概率的经典问题，理解还是不够透彻，把大家的讨论与理解记录下。概率为 0 的事件，必然不能发生吗？概率为 1 的事件，必然能发生吗？（知乎） 概率为 0 的事件，必然不能发生吗？（豆瓣） 一个简单却又很多人搞错的数学概念 关于概率为0的事件和不可能事件 与测度相关，相对较难测度（维基百科） 概率与测度 测度论与概率论基础]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>概率论</tag>
        <tag>数理统计</tag>
        <tag>测度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核子系统]]></title>
    <url>%2F2016%2F10%2F07%2FLinux%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Linux 内核子系统Linux 内核可分为 5 个子系统，包括：进程调度、内存管理、虚拟文件系统、网络、进程间通信； 进程调度（Process Scheduler），也称作进程管理，进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。 内存管理（Memory Manager），负责管理内存资源，提供虚拟内存机制； 虚拟文件系统（Virtual File System）,隐藏了硬件的具体细节，为所有的外部设备提供了统一的操作接口（open, read, write, close）； 网络（Network），网络子系统，负责管理系统的网络设备，其中也包含了网络协议与网络设备驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序； 进程间通信（IPC：Inter-Process Communication），包含多种进程间通信的方法，包括：信号量、共享内存、管道等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。 Reference 【Linux技术】嵌入式linux内核的五个子系统 Linux内核的整体架构]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
        <tag>子系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera-Machine Learning 之 Logistic Regression (逻辑回归)-0x02]]></title>
    <url>%2F2016%2F10%2F05%2FCoursera-Machine-Learning-%E4%B9%8B-Logistic-Regression-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-0x02%2F</url>
    <content type="text"><![CDATA[原文首发于个人CSDN博客：http://blog.csdn.net/kalenzh/article/details/43817321 Cost FunctionTraining set(训练集):$\{(x^{(1)}, (y^{(1)}), (x^{(2)}, (y^{(2)}), ... ,(x^{(m)}, (y^{(m)})\}$ m 个训练样本 $$x \in \begin{bmatrix} x_0\\ x_1\\ ...\\ x_n\\ \end{bmatrix} \space x_0 = 1, y \in \{0,1\}$$ $h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$ 如何选择拟合参数 $\theta$ ? 代价函数 线性回归：$J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}\frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2$ $Cost(h_\theta(x^{(i)}) , y^{(i)}) = \frac{1}{2}(h_\theta(x^{(i)}) - y^{(i)})^2$ Logistic 回归：$$Cost(h_\theta(x^{(i)}) , y^{(i)}) = \begin{cases} -log(h_\theta(x)) &amp; \text{if}\space y = 1\\ -log(1 - h_\theta(x)) &amp; \text{if}\space y = 0 \end{cases}$$Note: $y = 0 \ \text{or}\ 1\ \text{always}$ 结合函数图像比较好理解。 Simplified cost function and gradient descent$Cost(h_\theta(x) , y) = -y log(h_\theta(x)) - (1 - y)log(1 - h_\theta(x))$ $J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}Cost(h_\theta(x^{(i)}), y^{(i)}) = -\frac{1}{m}[\sum\limits_{i = 1}^{m} y^{(i)}log\space h_\theta(x^{(i)}) + (1 - y^{(i)})log(1 - h_\theta(x^{(i)})]$ 拟合参数 $\theta$: $\min\limits_{\theta}J(\theta)$ 针对一个新的 $x$ 预测输出值： Output $h_\theta(x) = \frac{1}{1+e^{-\theta^T x}}$ want $\min\limits_{\theta}J(\theta)$: Repeat {$\theta_j := \theta_j -\alpha\frac{\partial}{\partial\theta_j}J(\theta)$} $\frac{\partial}{\partial\theta_j}J(\theta) = \frac{1}{m}\sum\limits_{i = 1}^{m}(h_\theta(x^{(i)}), y^{(i)})x_j^{(i)}$ Advanced Optimization(高级优化)Optimization algorithm Gradient descent（梯度下降）Conjugate gradient（共轭梯度法）BFGS（变尺度法）L-BFGS（限制变尺度法） 后三种算法优点：不需要手动选择学习率一般情况下比梯度下来收敛得更快缺点：更加复杂 Example:$$\theta = \begin{bmatrix} \theta_0\\ \theta_1\\ \end{bmatrix}$$ $J(\theta) = (\theta_1 - 5)^2 + (\theta_2 - 5)^2$ $\frac{\partial}{\partial\theta_1}J(\theta) = 2(\theta_1 - 5)$ $\frac{\partial}{\partial\theta_2}J(\theta) = 2(\theta_2 - 5)$ 12345678910function [jVal, gradient] = costFunction(theta)truejVal = (theta(1) - 5)^2 + (theta(2) - 5)^2;truegradient = zeros(2, 1);truegradient(1) = 2*(theta(1) - 5);truegradient(2) = 2*(theta(2) - 5);options = optimset(&apos;GradObj&apos;, &apos;on&apos;, &apos;MaxIter&apos;, &apos;100&apos;);initialTeta = zeros(2,1);[optTheta, functionVal, exitFlag] true= fminunc(@costFunction, initialTheta, options); Multiclass Classification: One-vs-allOne-vs-all(one-vs-rest) $h_\theta^{(i)}(x) = P(y = i | x;\theta)\space(x = 1,2,3)$ 给定新的输入 $x$ 值，选择对应类别： $\max\limits_{i} h_\theta^{(i)}(x)$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
        <tag>Machine Learning</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo代码高亮及代码块出现滚动条]]></title>
    <url>%2F2016%2F10%2F01%2FHexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%9D%97%E5%87%BA%E7%8E%B0%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[昨晚不知道因为改了什么配置，导致原先默认的Next主题的代码高亮失效了，接下来就是一番折腾。 代码高亮确认下站点的_config.yml，包含以下配置: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: true 接下来，就不能按照之前代码只用缩进块来表示为代码块了，这样不能高亮啊，真是神奇了 此时应该使用Markdown语法的，用``` code block ```，用六个 ` 把代码包起来```cpp (这里就可以随意发挥了，肯定不仅仅是cpp啊，java/javascript/C/objc/shell…写不下了) 此处应有代码``` 可以了，设置完成，就可以happy般的去 hexo clean;hexo g;hexo s, 本地查看一下代码高亮效果； 代码块滚动条本以为这样就万事大吉了，查看更新的网页，代码是高亮了，却出现了恶心的滚动条，不管代码是几行，都会出现那个滚动条，还是左右两边都有，作为强迫症患者怎么可以忍受，接着Google了一大圈，找到了良药 使用github和hexo搭建博客问题总结 感谢该博主精心研究 对应需要修改的内容node_modules/hexo-util/lib/highlight.js 将第一段代码修改成下面第二段代码，div标签修改为span，并增加换行br 12345678for (var i = 0, len = lines.length; i &lt; len; i++) &#123; line = lines[i]; if (tab) line = replaceTabs(line, tab); numbers += '&lt;div class="line"&gt;' + (firstLine + i) + '&lt;/div&gt;'; content += '&lt;div class="line'; content += (mark.indexOf(firstLine + i) !== -1) ? ' marked' : ''; content += '"&gt;' + line + '&lt;/div&gt;';&#125; 12345678for (var i = 0, len = lines.length; i &lt; len; i++) &#123; line = lines[i]; if (tab) line = replaceTabs(line, tab); numbers += '&lt;span class="line"&gt;' + (firstLine + i) + '&lt;/span&gt;&lt;br&gt;'; content += '&lt;span class="line'; content += (mark.indexOf(firstLine + i) !== -1) ? ' marked' : ''; content += '"&gt;' + line + '&lt;/span&gt;&lt;br&gt;';&#125; 代码高亮又恢复如初，就是得把之前几篇博客的代码中，加上``` ```]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>代码高亮</tag>
        <tag>滚动条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera-Machine Learning 之 Logistic Regression (逻辑回归)-0x01]]></title>
    <url>%2F2016%2F09%2F30%2FCoursera-Machine-Learning-%E4%B9%8B-Logistic-Regression-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92-0x01%2F</url>
    <content type="text"><![CDATA[原文首发于个人CSDN博客：http://blog.csdn.net/kalenzh/article/details/43734479 Hypothesis Representation （假设函数表达式） Logistic Regression Model Want $0\leq h_{\theta}(x) \leq 1$ $$\left. \begin{array}{l} h_{\theta}(x) = g(\theta^{T}x) \\ g(z) = \dfrac{1}{1+e^{-z}} \end{array} \right\} \to h_{\theta}(x) = \dfrac{1}{1+e^{-\theta^{T}x}}$$ Sigmoid functionLogistic functionThis two concept are basically synonyms and mean the same things.这两个函数概念基本是同义词，表示了$g(z)$ Sigmoid function wiki pedia Sigmoid 函数 百度百科 Interpretation of Hypothesis Output 对于一个已存在的数据集，我们需要为假设函数寻找一个$\theta$来拟合这个数据集； $h_{\theta}(x) = P(y=1|x;\theta)$在给定的特征值$x$，参数值$\theta$下，$y=1$的概率。 $P(y=0|x;\theta) = 1 - P(y=1|x;\theta)$ Decision Regression（决策边界） Logistic Regression 假设预测：如果 $h_{\theta}(x) \geq 0.5$，则 $y=1$；如果 $h_{\theta}(x) &lt; 0.5$，则 $y=0$； 在$g(z)$函数中如果 $z \geq 0$，则 $0.5\leq g(z)&lt;1$；如果 $z&lt;0$，则 $0&lt; g(z)&lt;0.5$； 所以$\color{blue}{\theta^{T}x \geq 0} \Rightarrow h_{\theta}(x)\geq0.5 \Rightarrow \color{blue}{y = 1}$$\color{navy}{\theta^{T}x &lt; 0} \Rightarrow h_{\theta}(x) &lt; 0.5 \Rightarrow \color{navy}{y = 0}$ Decision Boundary $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2})$ 假设： $\theta_{0} = -3, \theta_{1} = 1, \theta_{2} = 1$$$\theta = \begin{bmatrix} -3\\ 1\\ 1 \end{bmatrix}$$ Predict$&quot;y = 1&quot;$ if $ -3 + x_{1} + x_{2} \geq 0$$&quot;y = 0&quot;$ if $ -3 + x_{1} + x_{2} &lt; 0$ 这里可以看出 $x_{1} + x_{2} = 3 $ 这条线 是上述两个等式取不同值得分界线，这条分界线就被称为决策边界；在这里，决策边界是假设函数的一个属性，由参数决定，与数据集无关。 Non-linear decision Boundaries $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{2}^{2})$ support:$$\theta = \begin{bmatrix} -1\\ 0\\ 0\\ 1\\ 1 \end{bmatrix}$$ Predict$”y = 1”$ if $ -1 + x_{1}^{2} + x_{2}^{2} \geq 0$$”y = 0”$ if $ -1 + x_{1}^{2} + x_{2}^{2} &lt; 0$ 此时，决策边界为 $ x_{1}^{2} + x_{2}^{2} = 1$ 参数 $\theta$ 并不是由训练集所决定的，但是可以由训练集拟合出 $\theta$ 高阶复杂的假设函数： $h_{\theta}(x) = g(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{1}^{2} x_{2} + \theta_{5} x_{1}^{2} x_{2}^{2}+ ...)$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
        <tag>Machine Learning</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译] 用GDB学习C语言]]></title>
    <url>%2F2015%2F08%2F03%2F%E7%BF%BB%E8%AF%91-%E7%94%A8GDB%E5%AD%A6%E4%B9%A0C%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[原文：https://www.recurse.com/blog/5-learning-c-with-gdb 对于高级语言背景的使用者，就像Ruby, Scheme或者Haskell，学习 C 语言是极具挑战性的。除了要与 C 语言的低级特性，像手动管理内存和指针作斗争外，你还需要在没有交互式编程的环境下，完成整个学习过程。一旦你习惯了在交互式编程环境中的编程之路，你就会对这种写代码-编译-运行的循环过程感到无聊。 最近我想到可以使用GDB当做C的伪交互式编程环境。我一直将使用gdb作为学习C语言的工具，而不仅仅是调试C语言，并且这有很多的乐趣。 我这篇文章的目的，是告诉你，gdb是学习C语言的很好的工具。我将向你介绍一些我喜欢的gdb命令，然后我将演示如何使用gdb来理解，众所周知的C语言的棘手问题：数组和指针的区别。 gdb概述以下面这小段C程序作为开始，minimal.c12345int main()&#123; int i = 1337; return 0;&#125; 注意，程序中并没有其他内容，也没有单独的printf语句，看好了，这就是使用gdb学习C语言的勇敢新世界。 用gcc -g 选项对其进行编译，使得目标文件带有gdb调试信息，然后用gdb调试它。12$ gcc -g minimal.c -o minimal$ gdb minimal 这下你就能看到一个非常明显的gdb提示符，我之前承诺的交互式编程环境，这就是了：12(gdb) print 1 + 2$1 = 3 神奇的地球！ print 是gdb的内置命令，用来打印C语言表达式的赋值结果； 如果你不确定某条gdb命令是干嘛的，就在gdb提示符后面输入 help ‘command’； 接下来是一些比较有趣的例子：12(gbd) print (int) 2147483648$2 = -2147483648 这里我将忽略讨论为什么2147483648 == -2147483648，关键点在于即使是C语言也能在算术上玩出花样，而gdb也能深谙其中之道。 现在我们在main函数上设置一个断点，然后启动程序：12(gdb) break main(gdb) run 程序现在停在第三行，在 i 变量初始化之前，非常有趣，即使 i 没有初始化，我们也可以用print命令查看i的值12(gdb) print i$3 = 32767 在C语言中，一个没有初始化的局部变量的值是未定义的，所以gdb可能会在你的屏幕上输出与我不一样的值； 接下来，可以使用next命令执行当前行：123(gdb) next(gdb) print i$4 = 1337 用x命令检查内存在C语言中，变量存在标签连续的内存块中，一个变量的内存块，由以下两个数字特征来决定： 内存块中第一个字节的数值地址； 用字节衡量的内存块大小，变量块的大小由变量类型决定。 C语言有个独特的特性，就是你可以直接访问变量所在的内存块，‘&amp;’操作符将计算出变量的地址，sizeof 操作符将计算出变量在内存中的大小； 你可以用gdb玩一下这两个概念：1234(gdb) print &amp;i$5 = (int *) 0x7fff5fbff584(gdb) print sizeof(i)$6 = 4 总之，这里的意思是，变量 i 所在内存块起始地址为0x7fff5fbff584，并且占用了4个字节内存。 上面提到的变量在内存中的大小是取决于变量类型的，而且，sizeof操作符确实可以直接对类型进行操作：1234(gdb) print sizeof(int)$7 = 4(gdb) print sizeof(double)$8 = 8 这就意味着，至少在我的机器上，int 变量将占用4字节空间，而double变量将会占用8字节空间。 gdb随身携带了一个强有力的直接用来检查内存的工具：x 命令。 x 命令从一个特定的地址开始检查内存，它附带了格式化命令，用来准确控制你想要检查的字节数，还有就是你想怎么将其打印显示出来；如果还有什么疑问的话，在gdb提示符下运行 help x。 ‘&amp;’ 操作符计算出一个变量的地址，也就是说，我们可以让 x 命令 检查一下 &amp;i，从而就可以看出 i 的值下原始的字节是什么样的：12(gdb) x/4xb &amp;i0x7fff5fbff584: 0x39 0x05 0x00 0x00 上面的标志标明我要检查的是4个字节，并格式化为16进制数，每次一个字节；我选择检查4个字节是因为 i变量在内存中占用的大小就是4个字节，打印的结果，显示出了它在内存中原始的字节挨着字节的表示。 有个需要铭记的微妙的地方就是，在英特尔（Intel）处理器的机器上，原始字节是按照“小端”顺序存储的；与人类文字符号不同，它的低位数是存在内存的前面部分的。 一个验证这个问题的方法就是：给i一个特定的值，并重新检查相应的内存块；123(gdb) set var i = 0x12345678(gdb) x/4xb &amp;i0x7fff5fbff584: 0x78 0x56 0x34 0x12 用ptype命令检查类型ptype命令可能是我最喜欢的命令了，它会告诉我一个C表达式的类型（变量，函数等）；123456(gdb) ptype itype = int(gdb) ptype &amp;itype = int *(gdb) ptype maintype = int (void) 类型本身在C语言中是挺复杂的，但是ptype会给你一个交互式的查看方式。 指针和数组C语言的数组是一个神奇且微妙的概念，我们这一节的计划是写个小程序，并在gdb调试中探索下数组的意义； 编写以下代码，arrays.c:12345int main()&#123; int a[] = &#123;1,2,3&#125;; return 0;&#125; 用-g标志编译，用gdb运行起来，然后next到初始化数组那一行；12345$ gcc -g arrays.c -o arrays$ gdb arrays(gdb) break main(gdb) run(gdb) next 这个时候你就可以打印出a的内容，并检查它的类型：1234(gdb) print a$1 = &#123;1, 2, 3&#125;(gdb) ptype atype = int [3] 现在我们的程序已经在gdb里正常运行了，现在要做的第一件事就是用x命令查看下a在内存里的情况：123(gdb) x/12xb &amp;a0x7fff5fbff56c: 0x01 0x00 0x00 0x00 0x02 0x00 0x00 0x000x7fff5fbff574: 0x03 0x00 0x00 0x00 这就意味着 a 变量所在内存块起始地址为0x7fff5fbff56c。 前四个字节存储a[0]，接下来四个字节存储a[1]，最后四个字节存储a[2]。 你的确还可以通过 sizeof 知道 a 在内存中的大小是12个字节：12(gdb) print sizeof(a)$2 = 12 这个时候，数组看起来就相当像数组了。他们有自己的类数组类型和存储成员的连续内存块。然而，在现实情况中，数组扮演得更像一些指针。举个例子，我们可以对a做指针运算：1234= preserve do :escaped (gdb) print a + 1 $3 = (int *) 0x7fff5fbff570 也就是说，a+1 指向的是个int指针，指向地址为0x7fff5fbff570。 这个时候，你应该本能地想到将这个指针传递给x命令，然后看看发生了什么：1234= preserve do :escaped (gdb) x/4xb a + 1 0x7fff5fbff570: 0x02 0x00 0x00 0x00 这就可以看出0x7fff5fbff570 这个地址比a的第一个字节地址 0x7fff5fbff56c 大4. 由于给定的int的值是要占据4个字节的，这就意味着a+1指向a[1]. 实际上，C语言的数组索引是指针运算的语法糖：a[i]和*(a + i)是相等的。你可以在gdb里试试看：1234567891011121314= preserve do :escaped (gdb) print a[0] $4 = 1 (gdb) print *(a + 0) $5 = 1 (gdb) print a[1] $6 = 2 (gdb) print *(a + 1) $7 = 2 (gdb) print a[2] $8 = 3 (gdb) print *(a + 2) $9 = 3 我们可以看出，在一些情况下，a扮演者数组的角色，而在另外一些情况下，a又像个指向它第一个元素的指针，这到底怎么回事？ 答案就是：在C语言中，当一个变量被命名为数组是，它就退化为指向数组第一个元素的指针。 这个规则有两个例外情况：一个是对数据进行sizeof操作，另一个是对数据进行&amp;操作。 实际上，对a进行&amp;操作时，a并不会退化为指针，这就带来了个有趣的问题：a退化为指针和&amp;a是不是有什么不同？ 从数值上看，他们代表的是同样的地址：123456= preserve do :escaped (gdb) x/4xb a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 (gdb) x/4xb &amp;a 0x7fff5fbff56c: 0x01 0x00 0x00 0x00 然而，他们的类型是不同，我们已经看过退化为指针的a是个指向a的第一个元素的指针，所以它的类型必定为int*。至于&amp;a的类型，我们可以直接请教一下gdb：1234= preserve do :escaped (gdb) ptype &amp;a type = int (*)[3] 也就是说，&amp;a是个指向三个整型数数组的指针。这就说得通了：对a进行&amp;操作，a并不会退化，并且a的类型是int[3]。 通过对a的退化值和&amp;a进行指针运算，你可以观察下两者的行为区别：123456= preserve do :escaped (gdb) print a + 1 $10 = (int *) 0x7fff5fbff570 (gdb) print &amp;a + 1 $11 = (int (*)[3]) 0x7fff5fbff578 注意到，a+1 就是给指针加4，而给&amp;a + 1是给指针加12！ 指向a的指针实际上是退化成&amp;a[0]：1234= preserve do :escaped (gdb) print &amp;a[0] $11 = (int *) 0x7fff5fbff56c 结论希望我说服了你，gdb是个学习C语言环境，它简洁而又富有探索意味。你可以打印表达式的值，检查内存的连续字节，用ptype鼓捣一下类型系统。 如果你想知道更多的如何通过gdb学习C语言的内容，以下是我的一些建议： 使用gdb去通过这个挑战 Ksplice pointer challenge.； 了解一下结构体在内存中是怎么存储的，并拿它与数组进行比较； 使用gdb的 disassemble命令学习汇编语言，一个特别有趣的练习是了解西函数是怎么调用堆栈进行工作的； 检查下gdb的 ‘tui’ 模式，它提供一个在常规gdb之上的ncurses图层；在OS X系统中，你可能需要通过源码来安装gdb。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 100. Same Tree]]></title>
    <url>%2F2015%2F06%2F30%2FLeetCode-100-Same-Tree%2F</url>
    <content type="text"><![CDATA[100.Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 给定两个二叉树，写个函数来检查他们是否相等； 考虑两个二叉树的相等于否，需要判断他们结构上是否一致并且对应每个节点上的值是否相等。 12345678910111213141516171819/*** Definition for binary tree* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;* &#125;;*/class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (p == NULL &amp;&amp; q == NULL) return true; if ((!p &amp;&amp; q) || (p &amp;&amp; !q) || (p-&gt;val != q-&gt;val)) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; tip: 两树都为空，返回true； 两树其中一个为空，另一个不为空，或者值不相等，返回false； 当前节点值相等，则嵌套判断两树的左右树是否相等；]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Algorithm]算法(字符串移动，单词翻转)]]></title>
    <url>%2F2015%2F06%2F25%2FAlgorithm-%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E5%8A%A8%EF%BC%8C%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目1：定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部，如把字符串abcdef左旋转2位得到字符串cdefab。 请实现字符串左旋转的函数，要求对长度为n的字符串操作的时间复杂度为O(n)，空间复杂度为O(1) 题目2：输入一个英文句子，番句子中单词的顺序，但单词内字符的顺序不变。句子中单词以空格符隔开。句子中标点符号和普通字母一样处理。 例如输入“I am a student.”，则输出“student. a am I”。 解决方法：先将整个句子翻转，再将其中的每个单词翻转 Code (cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; void reverse(char *s, int from, int to) &#123; while(from &lt; to) &#123; char t = s[from]; s[from++] = s[to]; s[to--] = t; &#125; &#125; void WordRotateString(char *s) &#123; reverse(s, 0, strlen(s)-1); int start = 0; int end = 0; while(s[start] !='\0') &#123; if(s[end] == '\0') break; if(s[end] == ' ') &#123; reverse(s, start, end-1); end++; start = end; &#125; else end++; &#125; &#125; void LeftRotateString(char *s, int n,int m) &#123; m %= n; reverse(s, 0, m-1); reverse(s, m, n-1); reverse(s, 0, n-1); &#125; int main(int argc, char **argv) &#123; //反转字符 string s = "abcdefg"; cout &lt;&lt; s &lt;&lt; endl; LeftRotateString((char *)s.c_str(), s.length(), 2); cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; endl; //单词反转 s = "I am a student."; cout &lt;&lt; s &lt;&lt; endl; WordRotateString((char *)s.c_str()); cout &lt;&lt; s &lt;&lt; endl; return 0; &#125; Reference程序员编程艺术：第一章、左旋转字符串]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 27.Remove Element]]></title>
    <url>%2F2015%2F06%2F23%2FLeetCode-27-Remove-Element%2F</url>
    <content type="text"><![CDATA[27.Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 给定一个整型数组 A 和一个整型数 v，删除 A 中所有与 v 相等的元素，并返回新的数组长度； 元素的顺序可以更改，这并不影响你返回新的数组长度的大小。 1234567891011121314class Solution &#123;public: int removeElement(int A[], int n, int elem) &#123; int j = 0; for (int i = 0; i &lt; n; i++) &#123; if(A[i] == elem) &#123; continue; &#125; else &#123; A[j++] = A[i]; &#125; &#125; return j; &#125;&#125;; tip: 不能多开辟空间，只能使用原有的数据，那就定义两个位移来分别判断； 一开始出现的错误是更改过的串A[j++]没有赋值，只做了j++； 可以再简洁一点123456789101112class Solution &#123;public: int removeElement(int A[], int n, int elem) &#123; int j = 0; for (int i = 0; i &lt; n; i++) &#123; if(A[i] != elem) &#123; A[j++] = A[i]; &#125; &#125; return j; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 7.Reverse Integer]]></title>
    <url>%2F2015%2F06%2F18%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[7.Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 整数反转，忽略符号部分。 12345678910111213141516171819202122232425class Solution &#123;public: int reverse(int x) &#123; bool isPositive = true; if (x == INT_MIN || x == INT_MAX) return 0; if (x &lt; 0) &#123; isPositive = false; x *= -1; &#125; long long res = 0; while(x) &#123; res = res*10 + x%10; x/=10; &#125; if(res &gt; INT_MAX) return 0; if(!isPositive) &#123; res *= -1; &#125; return res; &#125;&#125;; tip:1.一开始漏掉了最前面一句判断的，溢出之后都要返回0；2.然后是后面反转之后，因为定义的是long long，所以也要判断返回的是否会溢出。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2015%2F06%2F14%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[1. Two SumGiven an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 给定一个整型数组，找到两个数，使得两个数相加的和为指定的目标数； 注意：索引1必须小于索引2 (index1 &lt; index2) 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; int vSize = numbers.size(); vector&lt;int&gt; vIndex; map&lt;int,int&gt; mapNum; int index; for (int i = 0; i &lt; vSize; ++i) &#123; index = mapNum[target - numbers[i]]; if(index) &#123; vIndex.push_back(index); vIndex.push_back(i+1); break; &#125; mapNum[numbers[i]] = i+1; &#125; return vIndex; &#125;&#125;; tip: 暴力解决, 两个for循环, 时间复杂度达到了O(n^2), 不符合要求； 用空间换时间，把对应数及索引创建一个map； 从目标数里减去一个数，查找另外一个数是否在map中，over； note:12vIndex.push_back(index);vIndex.push_back(i+1); 这两句话顺序不可互换, 因为结果要求index1 &lt; index2; index 查找出来的数, 其实是在这句代码1mapNum[numbers[i]] = i+1; 已经加入map中的, 索引 i 一直在递增, 所以 index &lt;= i, 要先加入到返回的vector中。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL injection(SQL 注入攻击) 原理浅析]]></title>
    <url>%2F2015%2F06%2F03%2FSQL-injection-SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB-%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.database 数据库A database is an organized collection of data. The data is typically organized to model aspects of reality in a way that supports processes requiring information. 数据库，简单来说可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。 数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。 2.SQL语句结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。1986年10月，美国国家标准学会对SQL进行规范后，以此作为关系式数据库管理系统的标准语言（ANSI X3. 135-1986），1987年得到国际标准组织的支持下成为国际标准。不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。 sql 主要用于对数据库进行一些数据的增、删、改、查操作，数据库管理员使用sql语言对数据库进行管理，部分数据的使用者，使用sql查询获取自己需要的数据。 假设我们拥有一个学生信息管理系统，其中有一张表存储学生的基本信息， 表名 STUDENT_INFO 字段 stuid,name,sex,hometown（对应：学号，姓名，性别，籍贯） STUDENT_INFO stuid name sex hometown 1 Tom M LA 2 Andy F NY 3 Sam M Seattle 12345SELECT * FROM STUDENT_INFO ; -- 查询表中所有记录SELECT name FROM STUDENT_INFO; -- 查询表中所有姓名记录SELECT hometown FROM STUDENT_INFO where name='Tom'; -- 查询出Tom的家乡 3. SQL injectionsql 注入攻击是黑客常用的数据库攻击手段，通过对sql 查询语句的重组与技巧性“填空游戏”，来获取非正常途径下数据库返回的信息。 通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 假如现在需要查询Tom的家乡信息，标准语句1SELECT hometown FROM STUDENT_INFO where name='Tom'; -- 查询出Tom的家乡 现在再拼接出另外一条语句，获取所有人的家乡信息1SELECT hometown FROM STUDENT_INFO where name='Tom' or '1'='1'; 就这样，原本只能获取到Tom的家乡，现在变成能够获取到所有人的家乡信息了，如果这个信息是个人电话号码、身份证号等其他敏感信息，后果不堪设想； where 语句后是一个逻辑判断 原来只有当名字为Tom时，才会返回对应查询的内容，现在拼接了一个‘1’=‘1’，这个等式是恒为真的，所以where后面的语句也就始终为TRUE; 如果这条查询语句是嵌入到Web页面用来查询某网站的语句，本来返回的是个人信息，这么一玩，就可以拿到当前网站数据库中所有其他用户的信息了 现在剥离sql语句，如果表单中只让我们填写要查询的对象“Tom”，要怎么拼接语句 你在表单中填写 Tom ，系统会自动将 Tom 用两个单引号 ‘’ 括起来 ‘Tom’ 再接入到sql语句中去， 这个时候，填空游戏来了， 在表单中填的就不能是where后面的所有字符了， 就变成 Tom‘ or ‘1’=’1 去掉了前后的两个单引号； 4.ReferenceDatabase wikipedia数据库 维基百科SQL wikipediaSQL 维基百科SQL 百度百科SQL注入攻击 百度百科SQL 注入攻击 维基百科SQL injection wikipedia]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>injection</tag>
        <tag>注入攻击</tag>
      </tags>
  </entry>
</search>
